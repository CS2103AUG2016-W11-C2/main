# A0148095X
###### /java/guitests/LoadCommandTest.java
``` java
public class LoadCommandTest extends ToDoListGuiTest {

    private final String command = LoadCommand.COMMAND_WORD + " ";
    private final String fileThatExists = "data/test/FileThatExists.xml";
    private final String fileThatDoesNotExist = "data/test/DoesNotExist.xml";
    private final String fileInWrongFormat = "data/test/WrongFormat.xml";
    private final String missingFileType = "data/test/invalid";
    private final String missingFileName = "data/test/.bad";    

    @Before
    public void setUp() throws Exception {
        super.setUp();

        // setup storage file
        Task toBeAdded = new Task(new Name("test"));
        ToDoList expectedTDL = new ToDoList();
        expectedTDL.addTask(toBeAdded);
        XmlToDoListStorage xmltdls = new XmlToDoListStorage(fileThatExists);
        xmltdls.saveToDoList(expectedTDL);
        
        // create empty file
        FileUtil.createFile(new File(fileInWrongFormat)); 
    }
    
    @After
    public void clean() throws Exception {
        // cleanup
        FileUtil.deleteFile(fileThatExists);
        FileUtil.deleteFile(fileInWrongFormat);
    }

    @Test
    public void load_pathValidFileExists_messageSuccess() {
        // load from an existing file
        commandBox.runCommand(command + fileThatExists);
        assertResultMessage(String.format(LoadCommand.MESSAGE_SUCCESS, fileThatExists));
    }

    @Test
    public void load_pathValidFileDoesNotExist_messageFileDoesNotExist() {
        // load from a non-existing file
        commandBox.runCommand(command + fileThatDoesNotExist);
        assertResultMessage(String.format(LoadCommand.MESSAGE_FILE_DOES_NOT_EXIST, fileThatDoesNotExist));
    }

    @Test
    public void load_pathValidFileWrongFormat_messageFileWrongFormat() {
        // file in wrong format
        commandBox.runCommand(command + fileInWrongFormat);
        assertResultMessage(String.format(LoadCommand.MESSAGE_FILE_WRONG_FORMAT, fileInWrongFormat));
    }

    @Test
    public void load_fileTypeInvalid_messagePathInvalid() {
        // invalid file type
        commandBox.runCommand(command + missingFileType);
        assertResultMessage(String.format(LoadCommand.MESSAGE_PATH_INVALID, missingFileType));
    }

    @Test
    public void load_fileNameInvalid_messagePathInvalid() {
        // invalid file name
        commandBox.runCommand(command + missingFileName);
        assertResultMessage(String.format(LoadCommand.MESSAGE_PATH_INVALID, missingFileName));
    }
}
```
###### /java/guitests/StoreCommandTest.java
``` java
public class StoreCommandTest extends ToDoListGuiTest {

    private final String validLocation = "data/test.xml";
    private final String badLocation = "test/.xml";
    private final String inaccessibleLocation = "C:/windows/system32/agendum/todolist.xml";
    
    @Test
    public void store_validLocation_messageSuccess() {
        //save to a valid directory
        commandBox.runCommand("store " + validLocation);
        assertResultMessage(String.format(StoreCommand.MESSAGE_SUCCESS, validLocation));        
    }
    
    @Test
    public void store_defaultLocation_messageSuccessDefaultLocation() {
        //save to default directory
        commandBox.runCommand("store default");
        assertResultMessage(String.format(StoreCommand.MESSAGE_LOCATION_DEFAULT, Config.DEFAULT_SAVE_LOCATION));
    }
    
    @Test
    public void store_invalidLocation_messageInvalidPath() {        
        //invalid Location
        commandBox.runCommand("store " + badLocation);
        assertResultMessage(StoreCommand.MESSAGE_PATH_WRONG_FORMAT);
    }
    
    @Test
    public void store_inaccessibleLocation_messageLocationInaccessible() {
        //inaccessible location
        commandBox.runCommand("store " + inaccessibleLocation);
        //assertResultMessage(StoreCommand.MESSAGE_LOCATION_INACCESSIBLE);
    }
    
    @Test
    public void store_fileExists_messageFileExists() throws IOException, FileDeletionException {     
        //file exists
        FileUtil.createIfMissing(new File(validLocation));
        commandBox.runCommand("store " + validLocation);
        assertResultMessage(StoreCommand.MESSAGE_FILE_EXISTS);
        FileUtil.deleteFile(validLocation);
        
    }
}
```
###### /java/seedu/agendum/commons/core/ConfigTest.java
``` java
    @Test
    public void setAliasTableFilePath_validPath_returnsTrue() {
        Config config = new Config();
        String validPath = "dropbox/table.xml";
        config.setAliasTableFilePath(validPath);
        
        assertEquals(validPath, config.getAliasTableFilePath());
    }

    @Test
    public void equals_differentObjectType_returnsFalse() {
        assertFalse(one.equals(new Object()));
    }

    @Test
    public void equals_same_returnsTrue() {
        assertTrue(one.equals(one));
    }

    @Test
    public void equals_symmetric_returnsTrue() {
        assertTrue(one.equals(another) && another.equals(one));
    }

    @Test
    public void hashCode_symmetric_returnsTrue() {
        assertTrue(one.hashCode() == another.hashCode());
    }
}
```
###### /java/seedu/agendum/commons/core/GuiSettingsTest.java
``` java
public class GuiSettingsTest {

    private Double windowWidth = 800.0;
    private Double windowHeight = 600.0;
    private int xPosition = 100;
    private int yPosition = 300;

    private GuiSettings one, another;
    
    @Before
    public void setUp() {
        one = new GuiSettings(windowWidth, windowHeight, xPosition, yPosition);
        another = new GuiSettings(windowWidth, windowHeight, xPosition, yPosition);
    }
    
    @Test
    public void equals_differentObject_returnsFalse() {
        assertFalse(one.equals(new Object()));
    }    

    @Test
    public void equals_symmetric_returnsTrue() {
        // equals to itself and similar object
        assertTrue(one.equals(one));
        assertTrue(one.equals(another));        
    }
    
    @Test
    public void equals_validInputDifferentSettings_returnsFalse() {
        // ----------- different settings ----------------
        GuiSettings differentSettings;

        Double differentWindowWidth = windowWidth*2;
        Double differentWindowHeight = windowHeight*2;
        int differentXPosition = xPosition*2;
        int differentYPosition = yPosition*2;

        // different width
        differentSettings  = new GuiSettings(differentWindowWidth, windowHeight, xPosition, yPosition);
        assertFalse(one.equals(differentSettings));
        
        // different height
        differentSettings  = new GuiSettings(windowWidth, differentWindowHeight, xPosition, yPosition);
        assertFalse(one.equals(differentSettings));
        
        // different x position
        differentSettings  = new GuiSettings(windowWidth, windowHeight, differentXPosition, yPosition);
        assertFalse(one.equals(differentSettings));
        
        // different y position
        differentSettings  = new GuiSettings(windowWidth, windowHeight, xPosition, differentYPosition);
        assertFalse(one.equals(differentSettings));
    }
    
    @Test
    public void hashcode_symmetric_returnsTrue() {
        assertEquals(one.hashCode(), another.hashCode());
    }    
}
```
###### /java/seedu/agendum/commons/core/VersionTest.java
``` java
    @Test
    public void versionComparableNotEqual() {
        Version original = new Version(0, 0, 0, false);

        // null
        Object nullObj = null;
        assertFalse(original.equals(nullObj));
        
        // Different object
        Object obj = new Object();
        assertFalse(original.equals(obj));
    }
```
###### /java/seedu/agendum/commons/util/CollectionUtilTest.java
``` java
public class CollectionUtilTest {

    public String string = "string";
    public int number = 1;
    public double decimal = 2.0;
    public boolean bool = true;
    public Object obj = new Object();
    
    public ArrayList<Object> noNullUniqueArrayList;
    
    @Before
    public void setUp() {
        noNullUniqueArrayList = new ArrayList<Object>();
        noNullUniqueArrayList.add(string);
        noNullUniqueArrayList.add(number);
        noNullUniqueArrayList.add(decimal);
        noNullUniqueArrayList.add(bool);
        noNullUniqueArrayList.add(obj);
    }
    
    @Test
    public void isNotNull() {        
        // No nulls
        assertTrue(CollectionUtil.isNotNull(string, number, decimal, bool, obj));
        
        // One null
        assertFalse(CollectionUtil.isNotNull(string, number, null, decimal, bool, obj));
    }    

    @Test
    public void assertNoNullNoNull() {
        // No assertion errors; all non-null
        CollectionUtil.assertNoNullElements(noNullUniqueArrayList);
    }
    
    @Test(expected = AssertionError.class)
    public void assertNoNullElementsNullCollection(){
        // The collection is null
        CollectionUtil.assertNoNullElements(null);
    }
    
    @Test
    public void elementsAreUnique() {
        // Unique
        assertTrue(CollectionUtil.elementsAreUnique(noNullUniqueArrayList));
        
        // Not unique
        ArrayList<Object> notUniqueArrayList = new ArrayList<>(noNullUniqueArrayList);
        notUniqueArrayList.add(string);
        assertFalse(CollectionUtil.elementsAreUnique(notUniqueArrayList));        
    }
}
```
###### /java/seedu/agendum/commons/util/FileUtilTest.java
``` java
    @Before
    public void setUp() throws IOException {
        filePathThatExists = "file_that_exists.test";
        fileThatExists = new File(filePathThatExists);
        FileUtil.createFile(fileThatExists);
        
        filePathThatDoesNotExist = "file_that_does_not_exist.test";
        fileThatDoesNotExist = new File(filePathThatDoesNotExist);
        
        filePathToBeDeleted = "file_to_be_deleted.test";
        fileToBeDeleted = new File(filePathToBeDeleted);
        FileUtil.createFile(fileToBeDeleted);      
        
        filePathWithParentDirectories = "data/test/file_with_parent_directories.test";
        fileWithParentDirectories = new File(filePathWithParentDirectories);
        
        filePathWithInvalidDirectoryName = "invalid <!.?> \0 /0 directory";
        fileWithInvalidDirectoryName = new File(filePathWithInvalidDirectoryName);
        
        filePathWithValidDirectoryName = "validdirectory";
        fileWithValidDirectoryName = new File(filePathWithValidDirectoryName);
    }

    @After
    public void cleanup() throws IOException {
        fileThatExists.delete();
        fileThatDoesNotExist.delete();
        fileToBeDeleted.delete();
        fileWithParentDirectories.delete();
        fileWithInvalidDirectoryName.delete();
        fileWithValidDirectoryName.delete();
    }
    
    @Test
    public void isFileExists_validPathFileDoesNotExist_returnsFalse() {
        assertFalse(FileUtil.isFileExists(filePathThatDoesNotExist));
        assertFalse(FileUtil.isFileExists(fileThatDoesNotExist));
    }
    
    @Test
    public void isFileExists_fileExists_returnsTrue() {
        assertTrue(FileUtil.isFileExists(filePathThatExists));
        assertTrue(FileUtil.isFileExists(fileThatExists));
    }
    
    @Test 
    public void createFile_validFilePathWithParentDirectories() throws IOException, FileDeletionException {
        assertTrue(FileUtil.createFile(fileWithParentDirectories));
        // create file again to test when it already exists
        assertFalse(FileUtil.createFile(fileWithParentDirectories));
        FileUtil.deleteFile(filePathWithParentDirectories);
    }
    
    @Test(expected = AssertionError.class)
    public void deleteFile_nullFilePath_throwsAssertionError() throws FileDeletionException {
        // invalid filepath
        FileUtil.deleteFile(null);
    }

    @Test
    public void deleteFile_validPathAndfile_success() throws FileDeletionException {
        FileUtil.deleteFile(filePathToBeDeleted);
        assertFalse(FileUtil.isFileExists(filePathToBeDeleted));
    }
    
    @Test (expected = FileDeletionException.class)
    public void deleteFile_validPathInvalidFile_throwsFileDeletionException() throws FileDeletionException {
        FileUtil.deleteFile(filePathThatDoesNotExist);
    }

    @Test
    public void isPathAvailable_validPathExistingFile_returnsTrue() {
        assertTrue(FileUtil.isPathAvailable(filePathThatExists));
    }

    @Test
    public void isPathAvailable_validPathNonExistingFile_returnsTrue() {
        assertTrue(FileUtil.isPathAvailable(filePathThatDoesNotExist));
    }
    
    @Test
    public void isPathAvailable_invalidPath_returnsFalse() {
        assertFalse(FileUtil.isPathAvailable(filePathWithInvalidDirectoryName));
    }    
    
    
    @Test (expected = IOException.class)
    public void createDirs_invalidDirectoryName_throwsIOException() throws IOException {
        FileUtil.createDirs(fileWithInvalidDirectoryName);
    }
    
    @Test
    public void createDirs_validDirectoryName_success() throws IOException {
        FileUtil.createDirs(fileWithValidDirectoryName);
    }
```
###### /java/seedu/agendum/commons/util/StringUtilTest.java
``` java
    /*
     * Valid equivalence partitions for path to file:
     *   - file path is valid
     *   - file name is valid
     *   - file type is valid
     *
     * Possible scenarios returning true:
     *   - valid relative path to a file
     *   - valid absolute path to a file for windows
     *   - valid absolute path to a file for Unix/MacOS
     *
     * Possible scenarios returning false:
     *   - file name missing
     *   - file type missing
     *   - null path
     *   - empty path
     *   - file path not in the right format
     *
     * The test method below tries to verify all above with a reasonably low number of test cases.
     */
    @Test
    public void isValidPathToFile(){
        // null and empty file paths
        assertFalse(StringUtil.isValidPathToFile(null)); // null path
        assertFalse(StringUtil.isValidPathToFile("")); // empty path
        
        // relative file paths
        assertFalse(StringUtil.isValidPathToFile("a")); // missing file type
        assertFalse(StringUtil.isValidPathToFile("data/.xml")); // invalid file name
        assertFalse(StringUtil.isValidPathToFile("data /valid.xml")); // invalid file path with spaces after
        
        assertTrue(StringUtil.isValidPathToFile("Program Files/data.xml")); // valid path to file with acceptable spaces in file path
        
        // absolute file paths for windows
        assertFalse(StringUtil.isValidPathToFile("1:/data.xml")); // invalid drive
        assertFalse(StringUtil.isValidPathToFile("C:/data/a")); // invalid file type
        assertFalse(StringUtil.isValidPathToFile("C:/data/.xml")); // invalid file name
        assertFalse(StringUtil.isValidPathToFile("C:/ data/valid.xml")); // invalid file path with spaces before

        assertTrue(StringUtil.isValidPathToFile("Z:/Program Files/some-other-folder/data.dat")); // valid drive, folder and file name
        
        // absolute file path for unix/MacOX
        assertFalse(StringUtil.isValidPathToFile("/usr/data")); // invalid file type
        assertFalse(StringUtil.isValidPathToFile("/usr/.xml")); // invalid file name
        assertFalse(StringUtil.isValidPathToFile("/ usr/data.xml")); // invalid file path with spaces before
        
        assertTrue(StringUtil.isValidPathToFile("/usr/bin/my folder/data.xml")); // valid folder and file name with spaces
    }
    
}
```
###### /java/seedu/agendum/logic/DateTimeUtilsTest.java
``` java
    @Test
    public void parseNaturalLanguageDateTimeString_emptyInput_emptyOptional() { 
        Optional<LocalDateTime> parsed = DateTimeUtils.parseNaturalLanguageDateTimeString("");
        assertFalse(parsed.isPresent());
    }

    @Test
    public void parseNaturalLanguageDateTimeString_nullInput_emptyOptional() { 
        Optional<LocalDateTime> parsed = DateTimeUtils.parseNaturalLanguageDateTimeString(null);
        assertFalse(parsed.isPresent());
    }

    @Test
    public void parseNaturalLanguageDateTimeString_inputNoGroups_emptyOptional() { 
        Optional<LocalDateTime> parsed = DateTimeUtils.parseNaturalLanguageDateTimeString("asd");
        assertFalse(parsed.isPresent());
    }    

}
```
###### /java/seedu/agendum/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_store_successful() throws Exception {
        // setup expectations
        ToDoList expectedTDL = new ToDoList();
        Task testTask = new Task(new Name("test_store"));
        expectedTDL.addTask(testTask);
        model.addTask(testTask);
        
        String location = "data/test_store_successful.xml";
        CommandResult result;
        String inputCommand;
        String feedback;
        EventsCollector eventCollector = new EventsCollector();
        
        // execute command and verify result
        inputCommand = "store " + location;
        result = logic.execute(inputCommand);
        feedback = String.format(StoreCommand.MESSAGE_SUCCESS, location);
        assertEquals(feedback, result.feedbackToUser);
        assertTrue(eventCollector.get(0) instanceof ChangeSaveLocationEvent);
        assertTrue(eventCollector.get(1) instanceof ToDoListChangedEvent);

        // execute command and verify result
        inputCommand = "store default";
        result = logic.execute(inputCommand);
        feedback = String.format(StoreCommand.MESSAGE_LOCATION_DEFAULT, Config.DEFAULT_SAVE_LOCATION);
        assertEquals(feedback, result.feedbackToUser);
        assertTrue(eventCollector.get(2) instanceof ChangeSaveLocationEvent);
        assertTrue(eventCollector.get(3) instanceof ToDoListChangedEvent);
    }
    
    @Test
    public void execute_store_fileExists_fail() throws Exception {
        // setup expectations
        ToDoList expectedTDL = new ToDoList();
        String location = "data/test_store_fail.xml";

        // create file
        FileUtil.createIfMissing(new File(location));
        
        // error that file already exists
        assertCommandBehavior("store " + location,
                String.format(StoreCommand.MESSAGE_FILE_EXISTS, location),
                expectedTDL,
                expectedTDL.getTaskList());

        // delete file
        FileUtil.deleteFile(location);
    }
    
    @Test
    public void execute_exit_success() {
        CommandResult result = logic.execute(ExitCommand.COMMAND_WORD);
        assertEquals(ExitCommand.MESSAGE_EXIT_ACKNOWLEDGEMENT, result.feedbackToUser);
    }
```
###### /java/seedu/agendum/logic/LogicManagerTest.java
``` java
    @Test
    public void executeLoad_fileExists_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.generateTask(999);
        ToDoList expectedTDL = new ToDoList();
        expectedTDL.addTask(toBeAdded);
        model.addTask(toBeAdded);

        // setup storage file
        String filePath = "data/test/load.xml";
        XmlToDoListStorage xmltdls = new XmlToDoListStorage(filePath);
        xmltdls.saveToDoList(expectedTDL);

        // execute command and verify result
        assertCommandBehavior("load " + filePath,
                String.format(LoadCommand.MESSAGE_SUCCESS, filePath),
                expectedTDL,
                expectedTDL.getTaskList());
        
        FileUtil.deleteFile(filePath);
    }

    @Test
    public void executeLoad_fileDoesNotExist_fail() throws Exception {
        // setup expectations
        ToDoList expectedTDL = new ToDoList();
        String filePath = "data/test/loadDoesNotExist.xml";

        // execute command and verify result
        assertCommandBehavior("load " + filePath,
                String.format(LoadCommand.MESSAGE_FILE_DOES_NOT_EXIST, filePath),
                expectedTDL,
                expectedTDL.getTaskList());
    }
```
###### /java/seedu/agendum/MainAppTest.java
``` java
public class MainAppTest {

    private MainApp mainApp;

    private Config defaultConfig;
    private UserPrefs defaultUserPrefs;
    private Hashtable<String, String> defaultAliasTable;
    
    // user prefs and alias table filepaths lead to empty files
    private Config configWithBadFilePaths; 
    // user prefs and alias table filepaths lead to read only files
    private Config configWithReadOnlyFilePaths;

    private final String pathToBadConfig = TestUtil.getFilePathInSandboxFolder("bad_config.json");
    private final String pathToReadOnlyConfig = TestUtil.getFilePathInSandboxFolder("read_only_config.json");

    private final String pathToBadUserPrefs = TestUtil.getFilePathInSandboxFolder("bad_user_prefs.json");
    private final String pathToReadOnlyUserPrefs = TestUtil.getFilePathInSandboxFolder("read_only_user_prefs.json");

    private final String pathToBadAliasTable = TestUtil.getFilePathInSandboxFolder("bad_alias_table.json");
    private final String pathToReadOnlyAliasTable = TestUtil.getFilePathInSandboxFolder("read_only_alias_table.json");

    @Before
    public void setUp() {
        mainApp = new MainApp();

        defaultConfig = new Config();
        defaultUserPrefs = new UserPrefs();
        defaultAliasTable = new Hashtable<String, String>();

        configWithBadFilePaths = generateConfigWithBadFilePaths();
        configWithReadOnlyFilePaths = generateConfigWithReadOnlyFilePaths();

        createEmptyFile(pathToBadConfig);
        createReadOnlyConfigFile(pathToReadOnlyConfig);

        createEmptyFile(pathToBadUserPrefs);
        createReadOnlyUserPrefsFile(pathToReadOnlyUserPrefs);

        createEmptyFile(pathToBadAliasTable);
        createReadOnlyAliasTableFile(pathToReadOnlyAliasTable);
    }

    @Test
    public void initConfig_nullFilePath_returnsDefaultConfig() {
        Config config = mainApp.initConfig(null);
        assertEquals(config, defaultConfig);
    }

    @Test
    public void initConfig_validFilePathInvalidFileFormat_returnsDefaultConfig() {
        Config config = mainApp.initConfig(pathToBadConfig);
        assertEquals(config, defaultConfig);
    }

    @Test
    public void initConfig_validFilePathValidFormatReadOnly_returnsDefaultConfigLogsWarning() {
        Config config = mainApp.initConfig(pathToReadOnlyConfig);
        assertEquals(config, defaultConfig);
    }

    @Test
    public void initPrefs_invalidFileFormat_returnsDefaultUserPrefs() {
        // Set up storage to point to bad user prefs
        mainApp.storage = new StorageManager("", "", pathToBadUserPrefs, null);

        UserPrefs userPrefs = mainApp.initPrefs(configWithBadFilePaths);
        assertEquals(userPrefs, defaultUserPrefs);

        // reset storage
        mainApp.storage = null;
    }

    @Test
    public void initPrefs_validFileReadOnly_returnsDefaultUserPrefsLogsWarning() {
        // Set up storage to point to read only prefs
        mainApp.storage = new StorageManager("", "", pathToReadOnlyUserPrefs, null);

        UserPrefs userPrefs = mainApp.initPrefs(configWithReadOnlyFilePaths);
        assertEquals(userPrefs, defaultUserPrefs);

        // reset storage
        mainApp.storage = null;
    }

    @Test
    public void initPrefs_exceptionThrowingStorage_returnsDefaultUserPrefsLogsWarning() {
        mainApp.storage = new ReadUserPrefsExceptionThrowingStorageManagerStub();

        UserPrefs userPrefs = mainApp.initPrefs(defaultConfig);
        assertEquals(userPrefs, defaultUserPrefs);

        // reset storage
        mainApp.storage = null;
    }

    @Test
    public void initAliasTable_invalidFileFormat_returnsEmptyHashtable() {
        // Set up storage to point to bad alias table
        mainApp.storage = new StorageManager("", pathToBadAliasTable, "", null);

        mainApp.initAliasTable(configWithBadFilePaths);
        Hashtable<String, String> actualAliasTable = CommandLibrary.getInstance().getAliasTable();
        assertEquals(actualAliasTable, defaultAliasTable);

        // reset storage and alias table
        mainApp.storage = null;
        CommandLibrary.getInstance().loadAliasTable(null);
    }

    @Test
    public void initAliasTable_validFileFormatReadOnly_returnsEmptyHashtable() {
        // Set up storage to point to read only alias table
        mainApp.storage = new StorageManager("", pathToReadOnlyAliasTable, "", null);

        mainApp.initAliasTable(configWithReadOnlyFilePaths);
        Hashtable<String, String> actualAliasTable = CommandLibrary.getInstance().getAliasTable();
        assertEquals(actualAliasTable, defaultAliasTable);

        // reset storage and alias table
        mainApp.storage = null;
        CommandLibrary.getInstance().loadAliasTable(null);
    }

    @Test
    public void initAliasTable_exceptionThrowingStorage_returnsDefaultHashtableLogsWarning() {
        mainApp.storage = new ReadAliasTableExceptionThrowingStorageManagerStub();

        mainApp.initAliasTable(defaultConfig);
        Hashtable<String, String> actualAliasTable = CommandLibrary.getInstance().getAliasTable();
        assertEquals(actualAliasTable, defaultAliasTable);

        // reset storage and alias table
        mainApp.storage = null;
        CommandLibrary.getInstance().loadAliasTable(null);
    }
    
    private void createEmptyFile(String filePath) {
        File file = new File(filePath);

        deleteIfExists(file);

        try {
            file.createNewFile();
        } catch (IOException e) {
            Assert.fail("Error creating empty file at: " + filePath);
        }
    }

    private void createReadOnlyConfigFile(String filePath) {
        File file = new File(filePath);

        // Ensure that the file is empty
        deleteIfExists(file);

        try {
            ConfigUtil.saveConfig(defaultConfig, filePath);
        } catch (IOException e) {
            Assert.fail("Error creating read only config file");
        }

        if (!file.setReadOnly()) {
            Assert.fail("Unable to set read only config to read only");
        }
    }

    private void createReadOnlyUserPrefsFile(String filePath) {
        File file = new File(filePath);

        // Ensure that the file is empty
        deleteIfExists(file);

        try {
            JsonUserPrefsStorage userPrefsStorage = new JsonUserPrefsStorage(filePath);
            userPrefsStorage.saveUserPrefs(defaultUserPrefs, filePath);
        } catch (IOException e) {
            Assert.fail("Error creating read only user prefs file");
        }

        if (!file.setReadOnly()) {
            Assert.fail("Unable to set read only user prefs to read only");
        }
    }

    private void createReadOnlyAliasTableFile(String filePath) {
        File file = new File(filePath);

        // Ensure that the file is empty
        deleteIfExists(file);

        try {
            JsonAliasTableStorage aliasTableStorage = new JsonAliasTableStorage(filePath);
            aliasTableStorage.saveAliasTable(defaultAliasTable, filePath);
        } catch (IOException e) {
            Assert.fail("Error creating read only alias table file");
        }

        if (!file.setReadOnly()) {
            Assert.fail("Unable to set read only alias table to read only");
        }
    }

    public void deleteIfExists(File file) {
        if (file.exists()) {
            file.delete();
        }
    }

    private Config generateConfigWithReadOnlyFilePaths() {
        Config config = new Config();
        config.setAliasTableFilePath(pathToReadOnlyAliasTable);
        config.setUserPrefsFilePath(pathToReadOnlyUserPrefs);
        return config;
    }

    private Config generateConfigWithBadFilePaths() {
        Config config = new Config();
        config.setAliasTableFilePath(pathToBadAliasTable);
        config.setUserPrefsFilePath(pathToBadUserPrefs);
        return config;        
    }

    /** Throws an IOException when readUserPrefs is called **/
    class ReadUserPrefsExceptionThrowingStorageManagerStub extends StorageManager {
        public ReadUserPrefsExceptionThrowingStorageManagerStub() {
            super("", "", "", null);
        }

        public Optional<UserPrefs> readUserPrefs() throws IOException {
            throw new IOException(this.getClass().getCanonicalName() +": IOException");
        }
    }    

    /** Throws an IOException when readAliasTable is called **/
    class ReadAliasTableExceptionThrowingStorageManagerStub extends StorageManager {
        public ReadAliasTableExceptionThrowingStorageManagerStub() {
            super("", "", "", null);
        }

        @Override
        public Optional<Hashtable<String, String>> readAliasTable() throws DataConversionException, IOException {
            throw new IOException(this.getClass().getCanonicalName() + ": IOException");
        }
    }
}
```
###### /java/seedu/agendum/model/NameTest.java
``` java
public class NameTest {
    private String invalidNameString = "Vishnu \n Rachael \n Weigang";
    private String validNameString = "Justin";
    
    private Name one;
    private Name another;
    
    @Before
    public void setUp() throws IllegalValueException {
        one = new Name(validNameString);
        another = new Name(validNameString);
    }
    
    @Test
    public void equals_symmetric_returnsTrue() throws IllegalValueException {
        assertTrue(one.equals(another) && another.equals(one));
    }
    
    @Test
    public void hashCode_symmetric_returnsTrue() throws IllegalValueException {
        assertTrue(one.hashCode() == another.hashCode());
    }
    
    @SuppressWarnings("unused")
    @Test (expected = IllegalValueException.class)
    public void name_invalid_throwsIllegalValueException() throws IllegalValueException {
        Name name = new Name(invalidNameString);
    }
}
```
###### /java/seedu/agendum/model/ToDoListTest.java
``` java
public class ToDoListTest {

    private Task alice, bob, charlie;
    private ToDoList one, another;
    
    @Before
    public void setUp() throws IllegalValueException{
        alice = new Task(new Name("meet alice"));
        bob = new Task(new Name("meet bob"));
        charlie = new Task(new Name("meet charlie"));
        
        one = new ToDoList();
        one.addTask(alice);
        one.addTask(bob);
        
        another = new ToDoList();
        another.addTask(alice);
        another.addTask(bob);
    }

    
    @Test
    public void equals_symmetric_returnsTrue() {
        assertTrue(one.equals(another) && another.equals(one));
    }
    
    @Test
    public void hashCode_symmetric_returnsTrue() {
        assertTrue(one.hashCode() == another.hashCode());
    }
    
    @Test
    public void getEmptyToDoList() {
        assertTrue(ToDoList.getEmptyToDoList().getTaskList().isEmpty());
    }
    
    @Test
    public void removeTask_taskExists_removedSuccessfully() throws TaskNotFoundException {
        one.removeTask(alice);
        assertFalse(one.getTaskList().contains(alice));
    }
    
    @Test (expected = TaskNotFoundException.class)
    public void removeTask_taskDoesNotExist_throwsTaskNotFoundException() throws TaskNotFoundException {
        one.removeTask(charlie);
    }
}
```
###### /java/seedu/agendum/model/UnmodifiableObservableListTest.java
``` java
    @Test
    public void mutatingMethodsDisabled() {

        final Class<UnsupportedOperationException> ex = UnsupportedOperationException.class;

        assertThrows(ex, () -> list.add(3));
        assertThrows(ex, () -> list.add(1, 2));
        assertThrows(ex, () -> list.add(1, null));

        assertThrows(ex, () -> list.addAll(2, 1));
        assertThrows(ex, () -> list.addAll(null, 1));
        assertThrows(ex, () -> list.addAll(backing));
        assertThrows(ex, () -> list.addAll(0, backing));

        assertThrows(ex, () -> list.set(0, 2));
        assertThrows(ex, () -> list.set(1, null));

        assertThrows(ex, () -> list.setAll(1, 2));
        assertThrows(ex, () -> list.setAll(1, null));
        assertThrows(ex, () -> list.setAll(backing));

        assertThrows(ex, () -> list.remove(0, 1));
        assertThrows(ex, () -> list.remove(null));
        assertThrows(ex, () -> list.remove(0));

        assertThrows(ex, () -> list.removeAll(backing));
        assertThrows(ex, () -> list.removeAll(1, 2));
        assertThrows(ex, () -> list.removeAll(null, 2));

        assertThrows(ex, () -> list.retainAll(backing));
        assertThrows(ex, () -> list.retainAll(1, 2));
        assertThrows(ex, () -> list.retainAll(1, null));

        assertThrows(ex, () -> list.replaceAll(i -> 1));

        assertThrows(ex, () -> list.sort(Comparator.naturalOrder()));
        assertThrows(ex, () -> list.sort(null));

        assertThrows(ex, () -> list.clear());

        final Iterator<Integer> iter = list.iterator();
        iter.next();
        assertThrows(ex, iter::remove);

        final ListIterator<Integer> liter = list.listIterator();
        liter.next();
        assertThrows(ex, liter::remove);
        assertThrows(ex, () -> liter.add(5));
        assertThrows(ex, () -> liter.set(3));
        assertThrows(ex, () -> list.removeIf(i -> true));
    }
    
    @SuppressWarnings("unused")
    @Test (expected = NullPointerException.class)
    public void unmodifiableObservableList_nullList_nullPointerExceptionThrown() {
        UnmodifiableObservableList<Object> nullList = new UnmodifiableObservableList<>(null);
    }
    
    @Test
    public void isEmpty_nonEmptyList_returnsFalse() {
        assertFalse(list.isEmpty());
    }

    @Test
    public void contains_existingItem_returnsTrue() {
        assertTrue(list.contains(ITEM_TWO));
    }

    @Test
    public void containsAll_sameList_returnsTrue() {
        assertTrue(list.containsAll(backing));
    }
    
    @Test
    public void containsAll_listWhichContainsOneExtraItem_returnsFalse() {
        final List<Integer> backingWithOneExtraItem = new ArrayList<>(backing);
        backingWithOneExtraItem.add(15);
        final UnmodifiableObservableList<Object> listWithOneExtraItem = new UnmodifiableObservableList<>(FXCollections.observableList(backingWithOneExtraItem));
        
        assertFalse(list.containsAll(listWithOneExtraItem));
    }

    @Test
    public void indexOf_validItem_returnsCorrectIndex() {
        final int itemToFind = ITEM_ONE;
        final int index = list.indexOf(itemToFind);
        
        assertEquals(index, 1);
    }
    
    @Test
    public void indexOf_invalidItem_returnsErrorIndex() {
        final int itemToFind = 999;
        final int index = list.indexOf(itemToFind);
        
        assertEquals(index, -1);
    }
    
    @Test
    public void lastIndexOf_validItem_returnsCorrectIndex() {
        final int itemToFind = ITEM_ZERO;
        final int itemToAdd = ITEM_ZERO; // add a duplicate so it become last object
        
        final List<Integer> backingWithDuplicate = new ArrayList<>(backing);
        backingWithDuplicate.add(itemToAdd);
        final UnmodifiableObservableList<Object> listWithDuplicate = new UnmodifiableObservableList<>(FXCollections.observableList(backingWithDuplicate));
        
        final int expectedIndex = listWithDuplicate.size()-1;
        final int actualIndex = listWithDuplicate.lastIndexOf(itemToFind);
        
        assertEquals(expectedIndex, actualIndex);
    }
    
    @Test
    public void lastIndexOf_invalidItem_returnsErrorIndex() {
        final int itemToFind = 888;
        final int index = list.lastIndexOf(itemToFind);
        
        assertEquals(index, -1);
    }
    
    @Test
    public void subList_sameItems_returnsTrue() {
        final int startIndex = 1;
        final int endIndex = 3; 
        List<Integer> subListOfBacking = backing.subList(startIndex, endIndex);
        List<Integer> subListOfList = list.subList(startIndex, endIndex);
        
        assertTrue(subListOfBacking.equals(subListOfList));
    }
    
    @Test
    public void toArray_sameItems_returnsTrue() {
        final Integer[] arrayWithSameItems = new Integer[]{ITEM_ZERO, ITEM_ONE, ITEM_TWO, ITEM_THREE, ITEM_FOUR};
        final Object[] convertedToObjectArray =  list.toArray();        
        final Integer[] convertedToIntegerArray = list.toArray(new Integer[0]);

        assertTrue(Arrays.deepEquals(arrayWithSameItems, convertedToObjectArray));
        assertTrue(Arrays.equals(arrayWithSameItems, convertedToIntegerArray));
    }
    
    @Test
    public void equals_symmetricList_returnsTrue() {
        final UnmodifiableObservableList<Object> one = new UnmodifiableObservableList<>(FXCollections.observableList(backing));
        final UnmodifiableObservableList<Object> another = new UnmodifiableObservableList<>(FXCollections.observableList(backing));

        assertTrue(one.equals(another) && another.equals(one));
        assertTrue(one.hashCode() == another.hashCode());
    }
    
    @Test
    public void listIterator_iterateWholeList_listMatches() {
        final ListIterator<Integer> liter = list.listIterator();
        int currentItem;
        int index;
        
        // cursor position 0 -> 1 (index 0)
        assertTrue(liter.hasNext());
        
        index = liter.nextIndex();
        assertEquals(index, 0);
        
        currentItem = liter.next();
        assertEquals(currentItem, ITEM_ZERO);
        
        // move cursor position 1 -> 2 -> 3
        liter.next();
        liter.next();
        
        // cursor position 3 -> 2 (index 2)
        assertTrue(liter.hasPrevious());
        
        index = liter.previousIndex();
        assertEquals(index, 2);
        
        currentItem = liter.previous();
        assertEquals(currentItem, ITEM_TWO);
    }
}
```
###### /java/seedu/agendum/model/UserPrefsTest.java
``` java
public class UserPrefsTest {

    private UserPrefs one, another;

    @Before
    public void setUp() {
        one = new UserPrefs();
        another = new UserPrefs();
    }

    @Test
    public void equals_differentObject_returnsFalse() {
        assertFalse(one.equals(new Object()));
    }

    @Test
    public void equals_symmetric_returnsTrue() {
        // equals to itself and object with same parameters
        assertTrue(one.equals(one));
        assertTrue(one.equals(another));
    }

    @Test
    public void hashcode_symmetric_returnsTrue() {
        assertEquals(one.hashCode(), another.hashCode());
    }

    @Test
    public void setGuiSettings_validInputs_successful() {
        final double expectedWidth = 222;
        final double expectedHeight = 333;
        final int expectedX = 444;
        final int expectedY = 555;
        final GuiSettings expectedGuiSettings = new GuiSettings(expectedWidth, expectedHeight, expectedX, expectedY);

        final UserPrefs userPrefs = new UserPrefs();
        userPrefs.setGuiSettings(expectedWidth, expectedHeight, expectedX, expectedY);
        GuiSettings actualGuiSettings = userPrefs.getGuiSettings();

        assertEquals(actualGuiSettings, expectedGuiSettings);
    }

}
```
###### /java/seedu/agendum/storage/StorageManagerTest.java
``` java
    @Test
    public void handleSaveLocationChangedEvent_validFilePath_success() {
        String validPath = "data/test.xml";
        storageManager.handleChangeSaveLocationEvent(new ChangeSaveLocationEvent(validPath));
        assertEquals(storageManager.getToDoListFilePath(), validPath);
    }
    
    @Test
    public void handleLoadDataRequestEvent_validPathToFileInvalidFile_throwsException() throws IOException, FileDeletionException {
        EventsCollector eventCollector = new EventsCollector();
        String validPath = "data/testLoad.xml";
        assert !FileUtil.isFileExists(validPath);
        
        // File does not exist
        storageManager.handleLoadDataRequestEvent(new LoadDataRequestEvent(validPath));
        DataLoadingExceptionEvent dlee = (DataLoadingExceptionEvent)eventCollector.get(0);
        assertTrue(dlee.exception instanceof NoSuchElementException);

        // File in wrong format
        FileUtil.createFile(new File(validPath));
        storageManager.handleLoadDataRequestEvent(new LoadDataRequestEvent(validPath));
        dlee = (DataLoadingExceptionEvent)eventCollector.get(1);
        assertTrue(dlee.exception instanceof DataConversionException);
        FileUtil.deleteFile(validPath);
    }

    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_nullPath_fail() {
        // null
        storageManager.setToDoListFilePath(null);
    }

    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_pathEmpty_fail() {
        // empty string
        storageManager.setToDoListFilePath("");
    }

    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_pathInvalid_fail() {
        // invalid file path
        storageManager.setToDoListFilePath("1:/.xml");
    }

    public void setToDoListFilePath_pathValid_success() {
        // valid file path
        String validPath = "test/test.xml";
        storageManager.setToDoListFilePath(validPath);
        assertEquals(validPath, storageManager.getToDoListFilePath());
    }
```
###### /java/seedu/agendum/storage/XmlAdaptedTaskTest.java
``` java
public class XmlAdaptedTaskTest {
    
    private Optional<LocalDateTime> optionalStartDateTime;
    private Optional<LocalDateTime> optionalEndDateTime;
    
    private XmlAdaptedTask xmlAdaptedTaskAllFields;
    private XmlAdaptedTask xmlAdaptedTaskUncompleted;
    private XmlAdaptedTask xmlAdaptedTaskNoStartDateTime;
    private XmlAdaptedTask xmlAdaptedTaskNoEndDateTime;
    
    @Before
    public void setUp() throws IllegalValueException {
        LocalDate date = LocalDate.now();
        
        LocalTime startTime = LocalTime.of(12, 0); // 12pm
        LocalDateTime startDateTime = LocalDateTime.of(date, startTime);
        optionalStartDateTime = Optional.of(startDateTime);

        LocalTime endTime = LocalTime.of(13, 0); // 1pm
        LocalDateTime endDateTime = LocalDateTime.of(date, endTime);
        optionalEndDateTime = Optional.of(endDateTime);
        
        Task taskWithAllFields = new Task(new Name("taskWithStartAndEndDateTimeCompleted"), optionalStartDateTime, optionalEndDateTime);
        taskWithAllFields.markAsCompleted();
        xmlAdaptedTaskAllFields = new XmlAdaptedTask(taskWithAllFields);

        Task taskMarkedAsUncompleted = new Task(new Name("taskWithStartAndEndDateTimeUncompleted"), optionalStartDateTime, optionalEndDateTime);
        xmlAdaptedTaskUncompleted = new XmlAdaptedTask(taskMarkedAsUncompleted);
        
        Task taskWithNoStartDateTime = new Task(new Name("taskWithNoStartDateTime"), Optional.ofNullable(null), optionalEndDateTime);
        taskWithNoStartDateTime.markAsCompleted();
        xmlAdaptedTaskNoStartDateTime = new XmlAdaptedTask(taskWithNoStartDateTime);
        
        Task taskWithNoEndDateTime = new Task(new Name("taskWithNoEndDateTime"), optionalStartDateTime, Optional.ofNullable(null));
        taskWithNoEndDateTime.markAsCompleted();
        xmlAdaptedTaskNoEndDateTime = new XmlAdaptedTask(taskWithNoEndDateTime);
    }
    
    public void assertTaskEqual(Task task, Optional<LocalDateTime> startDateTime, Optional<LocalDateTime> endDateTime, boolean isCompleted) {
        assertTrue(task.getStartDateTime().equals(startDateTime));
        assertTrue(task.getEndDateTime().equals(endDateTime));
        assertTrue(task.isCompleted() == isCompleted);
    }
    
    @Test
    public void toModelType() throws IllegalValueException {
        // Task with start date time, end date time, completed
        Task taskWithAllFields = xmlAdaptedTaskAllFields.toModelType();
        assertTaskEqual(taskWithAllFields, optionalStartDateTime, optionalEndDateTime, true);
        
        // Task with start date time, end date time, not completed
        Task taskMarkedAsUncompleted = xmlAdaptedTaskUncompleted.toModelType();
        assertTaskEqual(taskMarkedAsUncompleted, optionalStartDateTime, optionalEndDateTime, false);
        
        // Task with no start date time, is completed
        Task taskWithNoStartDateTime = xmlAdaptedTaskNoStartDateTime.toModelType();
        assertTaskEqual(taskWithNoStartDateTime, Optional.empty(), optionalEndDateTime, true);
        
        // Task with no end date time, is completed
        Task taskWithNoEndDateTime = xmlAdaptedTaskNoEndDateTime.toModelType();
        assertTaskEqual(taskWithNoEndDateTime, optionalStartDateTime, Optional.empty(), true);
    }
}
```
###### /java/seedu/agendum/storage/XmlToDoListStorageTest.java
``` java
    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_nullPath_throwsAssertionError() {
        String filePath = testFolder.getRoot().getPath() + "TempToDoList.xml";
        XmlToDoListStorage xmlToDoListStorage = new XmlToDoListStorage(filePath);

        xmlToDoListStorage.setToDoListFilePath(null);
    }

    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_emptyPath_throwsAssertionError() {
        String filePath = testFolder.getRoot().getPath() + "TempToDoList.xml";
        XmlToDoListStorage xmlToDoListStorage = new XmlToDoListStorage(filePath);

        // empty string
        xmlToDoListStorage.setToDoListFilePath("");
    }

    @Test(expected = AssertionError.class)
    public void setToDoListFilePath_invalidPath_throwsAssertionError() {
        String filePath = testFolder.getRoot().getPath() + "TempToDoList.xml";
        XmlToDoListStorage xmlToDoListStorage = new XmlToDoListStorage(filePath);

        // invalid file path
        xmlToDoListStorage.setToDoListFilePath("1:/.xml");
    }

    public void setToDoListFilePath_validPath_success() {
        String filePath = testFolder.getRoot().getPath() + "TempToDoList.xml";
        XmlToDoListStorage xmlToDoListStorage = new XmlToDoListStorage(filePath);

        // valid file path
        String validPath = "test/test.xml";
        xmlToDoListStorage.setToDoListFilePath(validPath);
        assertEquals(validPath, xmlToDoListStorage.getToDoListFilePath());
    }

}
```
