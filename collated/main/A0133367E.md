# A0133367E
###### /java/seedu/agendum/commons/events/logic/AliasTableChangedEvent.java
``` java
package seedu.agendum.commons.events.logic;

import seedu.agendum.commons.events.BaseEvent;

import java.util.*;

/**
 * Indicate the alias table in Logic's command library has changed
 */
public class AliasTableChangedEvent extends BaseEvent {

    public final String aliasedKeyChanged;
    public final Hashtable<String, String> aliasTable;

    public AliasTableChangedEvent(String aliasedKeyChanged, Hashtable<String, String> aliasTable) {
        this.aliasedKeyChanged = aliasedKeyChanged;
        this.aliasTable = aliasTable;
    }

    @Override
    public String toString() {
        return aliasedKeyChanged;
    }
}
```
###### /java/seedu/agendum/logic/commands/AliasCommand.java
``` java
package seedu.agendum.logic.commands;

import seedu.agendum.model.Model;

/**
 * Create an alias for a reserved command keyword
 */
public class AliasCommand extends Command {

    // COMMAND_WORD, COMMAND_FORMAT, COMMAND_DESCRIPTION are for display in help window
    public static final String COMMAND_WORD = "alias";
    public static final String COMMAND_FORMAT = "alias <original-command> <your-command>";
    public static final String COMMAND_DESCRIPTION = "create your shorthand command";
    public static final String MESSAGE_SUCCESS = "New alias <%1$s> created for <%2$s>";
    public static final String MESSAGE_FAILURE_ALIAS_IN_USE = "<%1$s> is already an alias for <%2$s>";
    public static final String MESSAGE_FAILURE_UNAVAILABLE_ALIAS = "<%1$s> is a reserved command word";
    public static final String MESSAGE_FAILURE_NON_ORIGINAL_COMMAND =
            "We don't recognise <%1$s> as an Agendum Command";
    public static final Object MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " mark m";

    private String aliasValue;
    private String aliasKey;
    private CommandLibrary commandLibrary;
    
    public AliasCommand(String aliasKey, String aliasValue) {
        this.aliasKey = aliasKey;
        this.aliasValue = aliasValue;
    }

    public void setData(Model model, CommandLibrary commandLibrary) {
        this.model = model;
        this.commandLibrary = commandLibrary;
    }

    @Override
    public CommandResult execute() {
        if (!commandLibrary.isReservedCommandKeyword(aliasValue)) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_NON_ORIGINAL_COMMAND, aliasValue));
        }

        if (commandLibrary.isExistingAliasKey(aliasKey)) {
            String associatedValue = commandLibrary.getAliasedValue(aliasKey);
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_ALIAS_IN_USE, aliasKey, associatedValue));
        }

        if (commandLibrary.isReservedCommandKeyword(aliasKey)) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_UNAVAILABLE_ALIAS, aliasKey));
        }
        
        commandLibrary.addNewAlias(aliasKey, aliasValue);
        return new CommandResult(String.format(MESSAGE_SUCCESS, aliasKey, aliasValue));
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/CommandLibrary.java
``` java

package seedu.agendum.logic.commands;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import org.reflections.Reflections;
import seedu.agendum.commons.core.EventsCenter;
import seedu.agendum.commons.core.LogsCenter;
import seedu.agendum.commons.events.logic.AliasTableChangedEvent;

/**
 * Manages and stores the various Agendum's reserved command keywords and their aliases
 */
public class CommandLibrary {

    private static final Logger logger = LogsCenter.getLogger(CommandLibrary.class);
    private List<String> allCommandWords = new ArrayList<String>();

    // The keys of the hash table are user-defined aliases
    // The values of the has table are Agendum's reserved command keywords
    private Hashtable<String, String> aliasTable = new Hashtable<String, String>();

    private static CommandLibrary commandLibrary = new CommandLibrary();

```
###### /java/seedu/agendum/logic/commands/CommandLibrary.java
``` java
    /**
     * Replace the current commandLibrary's aliasTable with the aliasTable provided
     */
    public void loadAliasTable(Hashtable<String, String> aliasTable) {
        this.aliasTable = aliasTable;
    }

    /**
     * Returns true if key is already an alias for a command keyword, false otherwise.
     */
    public boolean isExistingAliasKey(String key) {
        assert key != null;
        assert key.equals(key.toLowerCase());

        return aliasTable.containsKey(key);
    }

    /**
     * Precondition: key is an existing alias.
     * Returns the reserved command keyword that is aliased by key
     */
    public String getAliasedValue(String key) {
        assert isExistingAliasKey(key);

        return aliasTable.get(key);
    }

    /**
     * Returns true if value is a reserved command keyword, false otherwise
     */
    public boolean isReservedCommandKeyword(String value) {
        assert value != null;
        assert value.equals(value.toLowerCase());

        return allCommandWords.contains(value);
    }

    /**
     * Precondition: key is a new unique alias and not a command keyword;
     * value is a reserved command keyword.
     * Saves the new alias relationship (key can be used in place of value)
     */
    public void addNewAlias(String key, String value) {
        assert !isExistingAliasKey(key);
        assert !isReservedCommandKeyword(key);
        assert isReservedCommandKeyword(value);

        aliasTable.put(key, value);

        indicateAliasTableChanged(key + " aliased");
    }

    /**
     * Precondition: key is aliased to a command keyword.
     * Destroy the alias relationship (key can no longer be used in place of command keyword)
     */
    public void removeExistingAlias(String key) {
        assert isExistingAliasKey(key);

        aliasTable.remove(key);

        indicateAliasTableChanged(key + " unaliased");
    }

    /** Raises an event to indicate that the aliasTable in the command library has changed */
    private void indicateAliasTableChanged(String keyChanged) {
        EventsCenter eventCenter = EventsCenter.getInstance();
        eventCenter.post(new AliasTableChangedEvent(keyChanged, aliasTable));
    }

}
```
###### /java/seedu/agendum/logic/commands/CommandResult.java
``` java
    /**
     * Pre-condition: tasks and originalIndices must be of the same size.
     * Returns a string containing each task in tasks
     * with the corresponding number in originalIndices prepended
     */
    public static String tasksToString(List<ReadOnlyTask> tasks, List<Integer> originalIndices) {
        final StringBuilder builder = new StringBuilder();
        builder.append("\n");
        for (int i = 0; i < tasks.size(); i++) {
            builder.append("#").append(originalIndices.get(i)).append(": ");
            builder.append(tasks.get(i).getAsText());
        }
        return builder.toString();
    }

}
```
###### /java/seedu/agendum/logic/commands/DeleteCommand.java
``` java
    public DeleteCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToDelete = new ArrayList<>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
            tasksToDelete.add(taskToDelete);
        }

        try {
            model.deleteTasks(tasksToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS,
                CommandResult.tasksToString(tasksToDelete, targetIndexes)));
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

```
###### /java/seedu/agendum/logic/commands/MarkCommand.java
``` java
    public MarkCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToMark = new ArrayList<>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
            tasksToMark.add(taskToMark);
        }
        
        try {
            model.markTasks(tasksToMark);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (DuplicateTaskException pnfe) {
            model.restoreCurrentToDoListClone();
            return new CommandResult(MESSAGE_DUPLICATE);
        }

        return new CommandResult(MESSAGE_MARK_TASK_SUCCESS);
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

```
###### /java/seedu/agendum/logic/commands/RenameCommand.java
``` java
    /**
     * Constructor for rename command
     * @throws IllegalValueException only if the name is invalid
     */
    public RenameCommand(int targetIndex, String name)
            throws IllegalValueException {
        this.targetIndex = targetIndex;
        this.newTaskName = new Name(name);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToRename = lastShownList.get(targetIndex - 1);

        try {
            Task renamedTask = new Task(taskToRename);
            renamedTask.setName(newTaskName);
            model.updateTask(taskToRename, renamedTask);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, newTaskName));

    }

```
###### /java/seedu/agendum/logic/commands/ScheduleCommand.java
``` java
    public ScheduleCommand(int targetIndex, Optional<LocalDateTime> startTime,
            Optional<LocalDateTime> endTime) {
        if (startTime.isPresent() && endTime.isPresent()) {
            endTime = Optional.of(DateTimeUtils.balanceStartAndEndDateTime(startTime.get(), endTime.get()));
        }
        this.targetIndex = targetIndex;
        this.newStartDateTime = startTime;
        this.newEndDateTime = endTime;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToSchedule = lastShownList.get(targetIndex - 1);

        Task updatedTask = new Task(taskToSchedule);
        updatedTask.setStartDateTime(newStartDateTime);
        updatedTask.setEndDateTime(newEndDateTime);

        try {
            model.updateTask(taskToSchedule, updatedTask);         
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, updatedTask));
    }

    //@author
    public static String getName() {
        return COMMAND_WORD;
    }
        
    public static String getFormat() {
        return COMMAND_FORMAT;
    }
        
    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }

}
```
###### /java/seedu/agendum/logic/commands/UnaliasCommand.java
``` java
package seedu.agendum.logic.commands;

import seedu.agendum.model.Model;

/**
 * Create an alias for a reserved command keyword
 */
public class UnaliasCommand extends Command {

    // COMMAND_WORD, COMMAND_FORMAT, COMMAND_DESCRIPTION are for display in help window
    public static final String COMMAND_WORD = "unalias";
    public static final String COMMAND_FORMAT = "unalias <your-command>";
    public static final String COMMAND_DESCRIPTION = "remove a shorthand command";
    public static final String MESSAGE_SUCCESS = "Removed alias <%1$s>";
    public static final String MESSAGE_FAILURE_NO_ALIAS_KEY = 
            "The alias <%1$s> does not exist";
    public static final Object MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " m\n"
            + "(if m is aliased to mark)";

    private String aliasKey;
    private CommandLibrary commandLibrary;
    
    public UnaliasCommand(String aliasKey) {
        this.aliasKey = aliasKey;
    }

    public void setData(Model model, CommandLibrary commandLibrary) {
        this.model = model;
        this.commandLibrary = commandLibrary;
    }

    @Override
    public CommandResult execute() {
        if (!commandLibrary.isExistingAliasKey(aliasKey)) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_NO_ALIAS_KEY, aliasKey));
        }
        
        commandLibrary.removeExistingAlias(aliasKey);
        return new CommandResult(String.format(MESSAGE_SUCCESS, aliasKey));
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/UndoCommand.java
``` java
/**
 * Undo the last successful command that mutate the to do list
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
	public static final String COMMAND_FORMAT = "undo";
	public static final String COMMAND_DESCRIPTION = "undo the last change to your to-do list";
	
    public static final String MESSAGE_SUCCESS = "Previous command undone!";
    public static final String MESSAGE_FAILURE = "Nothing to undo!";
	
    @Override
    public CommandResult execute() {
        assert model != null;
        if (model.restorePreviousToDoListClone()) {
            return new CommandResult(MESSAGE_SUCCESS);
        } else {
            return new CommandResult(MESSAGE_FAILURE);
        }
    }
	
    public static String getName() {
        return COMMAND_WORD;
    }
	
    public static String getFormat() {
        return COMMAND_FORMAT;
    }
	
    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/UnmarkCommand.java
``` java
    public UnmarkCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToUnmark = new ArrayList<>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToUnmark = lastShownList.get(targetIndex - 1);
            tasksToUnmark.add(taskToUnmark);
        }
        
        try {
            model.unmarkTasks(tasksToUnmark);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (DuplicateTaskException pnfe) {
            model.restoreCurrentToDoListClone();
            return new CommandResult(MESSAGE_DUPLICATE);
        }

        return new CommandResult(MESSAGE_UNMARK_TASK_SUCCESS);
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(taskIds);
    }

    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareMark(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(taskIds);
    }
 
    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnmark(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(taskIds);
    }

    /**
     * Parses arguments in the context of the rename task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareRename(String args) {
        final Matcher matcher = RENAME_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCommand.MESSAGE_USAGE));
        }

        final String givenName = matcher.group("name").trim();
        final String givenIndex = matcher.group("targetIndex");
        Optional<Integer> index = parseIndex(givenIndex);

        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCommand.MESSAGE_USAGE));
        }

        try {
            return new RenameCommand(index.get(), givenName);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the alias command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAlias(String args) {
        final Matcher matcher = ALIAS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
        }

        String aliasKey = matcher.group("shorthand").toLowerCase();
        String aliasValue = matcher.group("commandword").toLowerCase();

        return new AliasCommand(aliasKey, aliasValue);
    }

    /**
     * Parses arguments in the context of the unalias command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnalias(String args) {
        final Matcher matcher = UNALIAS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnaliasCommand.MESSAGE_USAGE));
        }

        String aliasKey = matcher.group("shorthand").toLowerCase();

        return new UnaliasCommand(aliasKey);
    }

```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    /**
     * Returns the specified indices in the {@code command} if positive unsigned integer(s) are given.
     *   Returns an empty set otherwise.
     */
    private Set<Integer> parseIndexes(String args) {
        final Matcher matcher = TASK_INDEXES_ARGS_FORMAT.matcher(args.trim());
        Set<Integer> taskIds = new HashSet<>();

        if (!matcher.matches()) {
            return taskIds;
        }

        args = args.replaceAll("[ ]+", ",").replaceAll(",+", ",");

        String[] taskIdStrings = args.split(",");
        for (String taskIdString : taskIdStrings) {
            if (taskIdString.matches("\\d+")) {
                taskIds.add(Integer.parseInt(taskIdString));
            } else if (taskIdString.matches("\\d+-\\d+")) {
                String[] startAndEndIndexes = taskIdString.split("-");
                int startIndex = Integer.parseInt(startAndEndIndexes[0]);
                int endIndex = Integer.parseInt(startAndEndIndexes[1]);
                taskIds.addAll(IntStream.rangeClosed(startIndex, endIndex)
                        .boxed().collect(Collectors.toList()));
            }
        }

        if (taskIds.remove(0)) {
            return new HashSet<>();
        }

        return taskIds;
    }
    
```
###### /java/seedu/agendum/model/ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyToDoList newData) {
        toDoList.resetData(newData);
        logger.fine("[MODEL] --- successfully reset data of the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }
  
```
###### /java/seedu/agendum/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTasks(List<ReadOnlyTask> targets) throws TaskNotFoundException {
        for (ReadOnlyTask target: targets) {
            toDoList.removeTask(target);
        }
        backupCurrentToDoList();
        logger.fine("[MODEL] --- successfully deleted all specified targets from the to-do list");
        indicateToDoListChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        toDoList.addTask(task);      
        logger.fine("[MODEL] --- successfully added the new task to the to-do list");
        backupCurrentToDoList();
        updateFilteredListToShowAll();
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void updateTask(ReadOnlyTask target, Task updatedTask)
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        toDoList.updateTask(target, updatedTask);
        logger.fine("[MODEL] --- successfully updated the target task in the to-do list");
        backupCurrentToDoList();
        updateFilteredListToShowAll();
        indicateToDoListChanged();
    }

    @Override
    public synchronized void markTasks(List<ReadOnlyTask> targets) 
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        for (ReadOnlyTask target: targets) {
            toDoList.markTask(target);
        } 
        logger.fine("[MODEL] --- successfully marked all specified targets from the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void unmarkTasks(List<ReadOnlyTask> targets) 
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        for (ReadOnlyTask target: targets) {
            toDoList.unmarkTask(target);
        }
        logger.fine("[MODEL] --- successfully unmarked all specified targets from the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }

    /**
     * This is to restore the previous (second latest) list saved 
     * in the event of an "undo" operation
     */
    @Override
    public synchronized boolean restorePreviousToDoListClone() {
        assert !previousLists.empty();

        if (previousLists.size() == 1) {
            return false;
        } else {
            previousLists.pop();
            toDoList.resetData(previousLists.peek());
            logger.fine("[MODEL] --- successfully restored the previous the to-do list from this session");
            indicateToDoListChanged();
            return true;
        }
    }

    /**
     * This is to reverse any temporary changes to the to-do list
     * that have not been saved to storage or stack of previous lists (in the event of exceptions)
     */
    @Override
    public synchronized void restoreCurrentToDoListClone() {
        assert !previousLists.empty();

        logger.fine("[MODEL] --- successfully restored the current to-do list"
                + " before exceptions/temporary changes");

        toDoList.resetData(previousLists.peek());
    }
 
    private void backupCurrentToDoList() {
        ToDoList latestList = new ToDoList(this.getToDoList());
        previousLists.push(latestList);
    }

    private void clearAllPreviousToDoLists() {
        previousLists.clear();
    }


    //=========== Storage Methods ==========================================================================
    
```
###### /java/seedu/agendum/model/task/ReadOnlyTask.java
``` java
    /**
     * Format the tasks as text, showing all details including name, 
     * completion status, start and end time if any
     */
    default String getDetailedText() {
        String completionStatus = isCompleted() ? "Completed" : "Incomplete";
        String startTime = getStartDateTime().isPresent() ? getStartDateTime().get().toString() : "None";
        String endTime = getEndDateTime().isPresent() ? getEndDateTime().get().toString() : "None";

        return "Task name: " +
                getName() +
                " Status: " +
                completionStatus +
                " Start Time: " +
                startTime +
                " End Time: " +
                endTime +
                " Last Updated Time: " +
                getLastUpdatedTime().toString();
    }
}
```
###### /java/seedu/agendum/model/task/Task.java
``` java
/**
 * Represents a Task in the to do list.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {

    private static final int UPCOMING_DAYS_THRESHOLD = 7;

    private Name name;
    private boolean isCompleted;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime lastUpdatedTime;
    
    // ================ Constructor methods ==============================

    /**
     * Constructor for a floating task (with no deadline/start time or end time)
     */
    public Task(Name name) {
        assert CollectionUtil.isNotNull(name);
        this.name = name;
        this.isCompleted = false;
        this.startDateTime = null;
        this.endDateTime = null;
        setLastUpdatedTimeToNow();
    }
    
    /**
     * Constructor for a task with deadline only
     */
    public Task(Name name, Optional<LocalDateTime> deadline) {
        assert CollectionUtil.isNotNull(name);
        this.name = name;
        this.isCompleted = false;
        this.startDateTime = null;
        this.endDateTime = deadline.orElse(null);
        setLastUpdatedTimeToNow();
    }
    
    /**
     * Constructor for a task (event) with both a start and end time
     */
    public Task(Name name, Optional<LocalDateTime> startDateTime,
            Optional<LocalDateTime> endDateTime) {
        assert CollectionUtil.isNotNull(name);
        this.name = name;
        this.isCompleted = false;
        this.startDateTime = startDateTime.orElse(null);
        this.endDateTime = endDateTime.orElse(null);
        setLastUpdatedTimeToNow();
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDateTime(), source.getEndDateTime());
        if (source.isCompleted()) {
            this.markAsCompleted();
        }
        setLastUpdatedTime(source.getLastUpdatedTime());
    }
    
    // ================ Getter methods ==============================

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public boolean isCompleted() {
        return isCompleted;
    }

    @Override
    public boolean isUpcoming() {
        return !isCompleted() && hasTime() && getTaskTime().isBefore(
                LocalDateTime.now().plusDays(UPCOMING_DAYS_THRESHOLD));
    }

    @Override
    public boolean isOverdue() {
        return !isCompleted() && hasTime() && getTaskTime().isBefore(LocalDateTime.now());
    }

    @Override
    public boolean hasTime() {
        return (getStartDateTime().isPresent() || getEndDateTime().isPresent());
    }

    @Override
    public boolean isEvent() {
        return getStartDateTime().isPresent();
    }

    @Override
    public boolean hasDeadline() {
        return !getStartDateTime().isPresent() && getEndDateTime().isPresent();
    }

    @Override
    public Optional<LocalDateTime> getStartDateTime() {
        return Optional.ofNullable(startDateTime);
    }

    @Override
    public Optional<LocalDateTime> getEndDateTime() {
        return Optional.ofNullable(endDateTime);
    }

    @Override
    public LocalDateTime getLastUpdatedTime() {
        return lastUpdatedTime;
    }

    /**
     * Pre-condition: Task has a start or end time
     * Return the (earlier) time associated with the task (assumed to be start time)
     */
    private LocalDateTime getTaskTime() {
        assert hasTime();
        return getStartDateTime().orElse(getEndDateTime().get());
    }
    
    // ================ Setter methods ==============================
    
    public void setName(Name name) {
        this.name = name;
        setLastUpdatedTimeToNow();
    }
    
    public void markAsCompleted() {
        this.isCompleted = true;
        setLastUpdatedTimeToNow();
    }
    
    public void markAsUncompleted() {
        this.isCompleted = false;
        setLastUpdatedTimeToNow();
    }
    
    public void setStartDateTime(Optional<LocalDateTime> startDateTime) {
        this.startDateTime = startDateTime.orElse(null);
        setLastUpdatedTimeToNow();
    }
    
    public void setEndDateTime(Optional<LocalDateTime> endDateTime) {
        this.endDateTime = endDateTime.orElse(null);
        setLastUpdatedTimeToNow();
    }

    public void setLastUpdatedTime(LocalDateTime updatedTime) {
        this.lastUpdatedTime = updatedTime;
    }

    public void setLastUpdatedTimeToNow() {
        this.lastUpdatedTime = LocalDateTime.now().withNano(0);
    }

    // ================ Other methods ==============================

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int compareTo(Task other) {
        int comparedCompletionStatus = compareCompletionStatus(other);
        if (comparedCompletionStatus != 0) {
            return comparedCompletionStatus;
        }

        int comparedTaskTime = compareTaskTime(other);
        if (!isCompleted() && comparedTaskTime != 0) {
            return comparedTaskTime;
        }

        int comparedLastUpdatedTime = compareLastUpdatedTime(other);
        if (comparedLastUpdatedTime != 0) {
            return comparedLastUpdatedTime;
        }
        
        return compareName(other);
    }

    public int compareCompletionStatus(Task other) {
        return Boolean.compare(this.isCompleted(), other.isCompleted());
    }

    public int compareTaskTime(Task other) {
        if (this.hasTime() && other.hasTime()) {
            return this.getTaskTime().compareTo(other.getTaskTime());
        } else if (this.hasTime()) {
            return -1;
        } else if (other.hasTime()) {
            return 1;
        } else {
            return 0;
        }
    }

    public int compareLastUpdatedTime(Task other) {
        return other.getLastUpdatedTime().compareTo(this.getLastUpdatedTime());
    }

    public int compareName(Task other) {
        return this.getName().toString().compareTo(other.getName().toString());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, isCompleted, startDateTime, endDateTime);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### /java/seedu/agendum/model/task/UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
 
        if (contains(toAdd)) {
            logger.fine("[TASK LIST] --- Duplicate Task: " + toAdd.getDetailedText());
            EventsCenter.getInstance().post(new JumpToListRequestEvent(toAdd, false));
            throw new DuplicateTaskException();
        }

        internalList.add(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(toAdd, false));
        
        logger.fine("[TASK LIST] --- Added a Task: " + toAdd.getDetailedText());
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);

        if (!taskFoundAndDeleted) {
            logger.fine("[TASK LIST] --- Missing Task: " + toRemove.getDetailedText());
            throw new TaskNotFoundException();
        }

        logger.fine("[TASK LIST] --- Deleted a Task: " + toRemove.getDetailedText());

        return taskFoundAndDeleted;
    }
    
    /**
     * Replaces the equivalent task (to toUpdate) in the list with a new task (updatedTask).
     *
     * @throws TaskNotFoundException if no such task (toUpdate) could be found in the list.
     * @throws DuplicateTaskException if the updated task is a duplicate of an existing task in the list.
     */
    public boolean update(ReadOnlyTask toUpdate, Task updatedTask)
            throws TaskNotFoundException, DuplicateTaskException {
        assert toUpdate != null;
        assert updatedTask != null;

        final int taskIndex = internalList.indexOf(toUpdate);
        final boolean taskFoundAndUpdated = (taskIndex != -1);

        if (!taskFoundAndUpdated) {
            logger.fine("[TASK LIST] --- Missing Task: " + toUpdate.getDetailedText());
            throw new TaskNotFoundException();
        }

        if (contains(updatedTask)) {
            logger.fine("[TASK LIST] --- Duplicate Task: " + toUpdate.getDetailedText());
            EventsCenter.getInstance().post(new JumpToListRequestEvent(updatedTask, true));
            throw new DuplicateTaskException();
        }

        internalList.set(taskIndex, updatedTask);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(updatedTask, true));
        logger.fine("[TASK LIST] --- Updated Task: " + toUpdate.getDetailedText()
                + " updated to " + updatedTask.getDetailedText());

        return taskFoundAndUpdated;
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException if a duplicate will result from marking the task
     */
    public boolean mark(ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;

        logger.fine("[TASK LIST] --- Attempt to Mark Task: " + toMark.getDetailedText());

        Task markedTask = new Task(toMark);
        markedTask.markAsCompleted();
        boolean taskFoundAndMarked = update(toMark, markedTask);
        
        return taskFoundAndMarked;
    }
    
    /**
     * Unmarks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException if a duplicate will result from unmarking the task
     */
    public boolean unmark(ReadOnlyTask toUnmark) throws TaskNotFoundException, DuplicateTaskException {
        assert toUnmark != null;

        logger.fine("[TASK LIST] --- Attempt to Unmark Task: " + toUnmark.getDetailedText());

        Task unmarkedTask = new Task(toUnmark);
        unmarkedTask.markAsUncompleted();
        boolean taskFoundAndUnmarked = update(toUnmark, unmarkedTask);

        return taskFoundAndUnmarked;
    }

```
###### /java/seedu/agendum/model/ToDoList.java
``` java
    /**
     * Updates an existing task in the to-do list.
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task (to updatedTask) already exists.
     * @throws UniqueTaskList.TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean updateTask(ReadOnlyTask key, Task updatedTask)
            throws UniqueTaskList.TaskNotFoundException,
            UniqueTaskList.DuplicateTaskException {
        return tasks.update(key, updatedTask);
    }

    /**
     * Marks an existing task in the to-do list.
     * @throws UniqueTaskList.DuplicateTaskException if a duplicate task would result after marking key.
     * @throws UniqueTaskList.TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean markTask(ReadOnlyTask key) 
            throws UniqueTaskList.TaskNotFoundException, 
            UniqueTaskList.DuplicateTaskException {
        return tasks.mark(key);
    }

    /**
     * Unmarks an existing task in the to-do list.
     * @throws UniqueTaskList.DuplicateTaskException if a duplicate task would result after unmarking key.
     * @throws UniqueTaskList.TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean unmarkTask(ReadOnlyTask key) 
            throws UniqueTaskList.TaskNotFoundException,
            UniqueTaskList.DuplicateTaskException {
        return tasks.unmark(key);
    }
```
