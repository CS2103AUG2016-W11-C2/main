# A0148031R
###### /java/seedu/agendum/commons/events/ui/CloseHelpWindowRequestEvent.java
``` java
/**
 * An event that requests to close help window
 */
public class CloseHelpWindowRequestEvent extends BaseEvent{

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/agendum/commons/events/ui/JumpToListRequestEvent.java
``` java
/**
 * Indicates a request to jump to the list of tasks
 */
public class JumpToListRequestEvent extends BaseEvent {

    public final Task targetTask;
    public final boolean hasMultipleTasks;

    public JumpToListRequestEvent(Task task, boolean hasMultipleTasks) {
        this.targetTask = task;
        this.hasMultipleTasks = hasMultipleTasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/agendum/commons/events/ui/ShowHelpRequestEvent.java
``` java
/**
 * An event requesting to view the help page.
 */
public class ShowHelpRequestEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/agendum/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

 // COMMAND_WORD, COMMAND_FORMAT, COMMAND_DESCRIPTION are for display in help window
    public static final String COMMAND_WORD = "help";
    public static final String COMMAND_FORMAT = "help";
    public static final String COMMAND_DESCRIPTION = "view a summary of Agendum commands";
    public static final String MESSAGE_USAGE = COMMAND_WORD + "- "
            + COMMAND_DESCRIPTION;
    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/model/UserPrefs.java
``` java
    /**
     * Sets default window to be screen size
     */
    public UserPrefs(){
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        this.setGuiSettings(screenSize.getWidth(), screenSize.getHeight(), 0, 0);
    }

    public void setGuiSettings(double width, double height, int x, int y) {
        guiSettings = new GuiSettings(width, height, x, y);
    }

```
###### /java/seedu/agendum/ui/CommandBox.java
``` java
/**
 * Controller for the command box field
 *
 */
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";
    private static final String FIND_COMMAND = "find ";
    private static final String HELP_COMMAND = "help";
    private static final String RESULT_FEEDBACK = "Result: ";
    private static final String ERROR = "error";
    private static final Color MESSAGE_COLOR = Color.web("#ffffff");

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private StackPane messagePlaceHolder;
    private ResultPopUp resultPopUp;
    private static CommandBoxHistory commandBoxHistory;

    private Logic logic;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, StackPane messagePlaceHolder, 
            ResultPopUp resultPopUp, Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultPopUp, messagePlaceHolder, logic);
        commandBox.addToPlaceholder();
        commandBoxHistory = CommandBoxHistory.getInstance();
        return commandBox;
    }

    public void configure(ResultPopUp resultPopUp, StackPane messagePlaceHolder, Logic logic) {
        this.resultPopUp = resultPopUp;
        this.messagePlaceHolder = messagePlaceHolder;
        this.logic = logic;
        registerAsAnEventHandler(this);
        registerArrowKeyEventFilter();
        registerTabKeyEventFilter();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(commandTextField);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Executes the command and saves this command to history if comamnd input
     * is changed
     */
    @FXML
    private void handleCommandInputChanged() {
        //Take a copy of the command text
        commandBoxHistory.saveNewCommand(commandTextField.getText());
        String previousCommandTest = commandBoxHistory.getLastCommand();
        if(previousCommandTest.toLowerCase().trim().startsWith(FIND_COMMAND) && 
                previousCommandTest.toLowerCase().trim().length() > FIND_COMMAND.length()) {
            postMessage(Messages.MESSAGE_ESCAPE_HELP_WINDOW);
        } else {
            raise(new CloseHelpWindowRequestEvent());
        }

        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */

        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        if(!previousCommandTest.toLowerCase().equals(HELP_COMMAND)) {
            resultPopUp.postMessage(mostRecentResult.feedbackToUser);
        }
        logger.info(RESULT_FEEDBACK + mostRecentResult.feedbackToUser);
    }
    
    /**
     * Post meesage in the message place holder under the command box
     */
    private void postMessage(String message) {
        this.messagePlaceHolder.getChildren().clear();
        raise(new CloseHelpWindowRequestEvent());

        Label label = new Label(message);
        label.setTextFill(MESSAGE_COLOR);
        label.setContentDisplay(ContentDisplay.CENTER);
        label.setPadding(new Insets(0, 10, 0, 10));
        this.messagePlaceHolder.setAlignment(Pos.CENTER_LEFT);
        this.messagePlaceHolder.getChildren().add(label);
    }

    /**
     * Sets arrow key for scrolling through command history
     */
    private void registerArrowKeyEventFilter() {
        commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            KeyCode keyCode = event.getCode();
            if (keyCode.equals(KeyCode.UP)) {
                String previousCommand = commandBoxHistory.getPreviousCommand();
                commandTextField.setText(previousCommand);
            } else if (keyCode.equals(KeyCode.DOWN)) {
                String nextCommand = commandBoxHistory.getNextCommand();
                commandTextField.setText(nextCommand);
            } else {
                return;
            }
            commandTextField.end();
            event.consume();
        });
    }
    
    /**
     * Sets tab key for autocomplete
     */
    private void registerTabKeyEventFilter() {
        commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            KeyCode keyCode = event.getCode();
            if (keyCode.equals(KeyCode.TAB)) {
                Optional<String> parsedString = EditDistanceCalculator.findCommandCompletion(commandTextField.getText());
                if(parsedString.isPresent()) {
                    commandTextField.setText(parsedString.get());
                }
            } else {
                return;
            }
            commandTextField.end();
            event.consume();
        });
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(
                event, "Invalid command: " + commandBoxHistory.getLastCommand()));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(commandBoxHistory.getLastCommand());
        commandTextField.selectEnd();
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add(ERROR);
    }

}
```
###### /java/seedu/agendum/ui/CommandBoxHistory.java
``` java
/**
 * Stores previous valid and invalid commands in a linked list with a max size
 * New commands are added to the head of the linked list
 */
public class CommandBoxHistory {
    
    private static final int MAX_PREVIOUS_LINES = 15;
    private static final String PREVIOUS_QUERY = "previous";
    private static final String NEXT_QUERY = "next";
    private static final String EMPTY_QUERY = "";
    private static final String EMPTY_COMMAND = "";
    private final LinkedList<String> pastCommands;
    private ListIterator<String> iterator;
    private String lastCommand = "";
    private String lastQuery = EMPTY_QUERY;
    
    private static CommandBoxHistory instance = null;
    
    private CommandBoxHistory() {
        pastCommands = new LinkedList<>();
        iterator = pastCommands.listIterator();   
    }
    
    public static CommandBoxHistory getInstance() {
       if(instance == null) {
          instance = new CommandBoxHistory();
       }
       return instance;
    }

    public String getLastCommand() {
        return lastCommand;
    }

    /**
     * Retrieves the previous valid/invalid command.
     * If there is no previous command, returns an empty string to clear the command box
     */
    public String getPreviousCommand() {
        if(!iterator.hasNext()) {
            lastQuery = EMPTY_QUERY;
            return EMPTY_COMMAND;
        } else if(lastQuery.equals(NEXT_QUERY)) {
            iterator.next();
        } 
        lastQuery = PREVIOUS_QUERY;
        return iterator.next();
    }

    /**
     * Retrieves the next valid/invalid command.
     * If there is no next command, return an empty string to clear the command box
     */
    public String getNextCommand() {
        if (!iterator.hasPrevious()) {
            lastQuery = EMPTY_QUERY;
            return EMPTY_COMMAND;
        } else if(lastQuery.equals(PREVIOUS_QUERY)) {
            iterator.previous();
        }  
        lastQuery = NEXT_QUERY;
        return iterator.previous();

    }

    /**
     * Takes in the latest command string entered and add it to command box history.
     * Updates the iterator to point to the latest element 
     */
    public void saveNewCommand(String newCommand) {
       lastCommand = newCommand;
       pastCommands.addFirst(lastCommand);

       if (pastCommands.size() > MAX_PREVIOUS_LINES) {
           pastCommands.removeLast();
       }

       iterator = pastCommands.listIterator();
    }

}
```
###### /java/seedu/agendum/ui/CompletedTasksPanel.java
``` java
/**
 * Panel contains the list of completed tasks
 */
public class CompletedTasksPanel extends TasksPanel {
    private static final String FXML = "CompletedTasksPanel.fxml";
    private static ObservableList<ReadOnlyTask> mainTaskList;
    private MultipleSelectionModel<ReadOnlyTask> selectionModel;

    @FXML
    private ListView<ReadOnlyTask> completedTasksListView;

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    protected void setConnections(ObservableList<ReadOnlyTask> taskList) {
        mainTaskList = taskList;
        completedTasksListView.setItems(taskList.filtered(ReadOnlyTask::isCompleted));
        completedTasksListView.setCellFactory(listView -> new CompletedTasksListViewCell());
        configure();
    }
    
    private void configure() {
        selectionModel = completedTasksListView.getSelectionModel();
        completedTasksListView.setSelectionModel(null);
        completedTasksListView.addEventFilter(MouseEvent.MOUSE_PRESSED, Event::consume);
    }

    /**
     * Scrolls to the newly updated task and highlight for several seconds. If
     * there are multiple tasks updated, previous highlight will not be cleared.
     */
    public void scrollTo(Task task, boolean hasMultipleTasks) {
        Platform.runLater(() -> {
            
            int index = mainTaskList.indexOf(task) - mainTaskList.filtered(t -> !t.isCompleted()).size();
            completedTasksListView.scrollTo(index);
            completedTasksListView.setSelectionModel(selectionModel);
            
            if(hasMultipleTasks) {
                completedTasksListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
                completedTasksListView.getSelectionModel().select(index);
            } else {
                completedTasksListView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
                completedTasksListView.getSelectionModel().clearAndSelect(index);
            }
            
            PauseTransition delay = new PauseTransition(Duration.seconds(5));
            delay.setOnFinished(event -> completedTasksListView.getSelectionModel().clearSelection(index));
            delay.play();
        });
    }

    class CompletedTasksListViewCell extends ListCell<ReadOnlyTask> {
        public CompletedTasksListViewCell() {
            prefWidthProperty().bind(completedTasksListView.widthProperty());
            setMaxWidth(Control.USE_PREF_SIZE);
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, mainTaskList.indexOf(task) + 1).getLayout());
            }
        }
    }
}
```
###### /java/seedu/agendum/ui/FloatingTasksPanel.java
``` java
/**
 * Panel contains the list of uncompleted floating tasks
 */
public class FloatingTasksPanel extends TasksPanel {
    private static final String FXML = "FloatingTasksPanel.fxml";
    private static ObservableList<ReadOnlyTask> mainTaskList;
    private MultipleSelectionModel<ReadOnlyTask> selectionModel;

    @FXML
    private ListView<ReadOnlyTask> floatingTasksListView;

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    protected void setConnections(ObservableList<ReadOnlyTask> taskList) {
        mainTaskList = taskList;
        floatingTasksListView.setItems(taskList.filtered(task -> !task.isCompleted() && !task.hasTime()));
        floatingTasksListView.setCellFactory(listView -> new FloatingTasksListViewCell());
        configure();
    }
    
    private void configure() {
        selectionModel = floatingTasksListView.getSelectionModel();
        floatingTasksListView.setSelectionModel(null);
        floatingTasksListView.addEventFilter(MouseEvent.MOUSE_PRESSED, Event::consume);
    }

    /**
     * Scrolls to the newly updated task and highlight for several seconds. If
     * there are multiple tasks updated, previous highlight will not be cleared.
     */
    public void scrollTo(Task task, boolean hasMultipleTasks) {
        Platform.runLater(() -> {
            
            int index = mainTaskList.indexOf(task) - 
                    mainTaskList.filtered(t -> (t.hasTime() && !t.isCompleted())).size();
            floatingTasksListView.scrollTo(index);
            floatingTasksListView.setSelectionModel(selectionModel);
            
            if(hasMultipleTasks) {
                floatingTasksListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
                floatingTasksListView.getSelectionModel().select(index);
            } else {
                floatingTasksListView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
                floatingTasksListView.getSelectionModel().clearAndSelect(index);
            }
            
            PauseTransition delay = new PauseTransition(Duration.seconds(4));
            delay.setOnFinished(event -> floatingTasksListView.getSelectionModel().clearSelection(index));
            delay.play();
        });
    }

    class FloatingTasksListViewCell extends ListCell<ReadOnlyTask> {
        public FloatingTasksListViewCell() {
            prefWidthProperty().bind(floatingTasksListView.widthProperty());
            setMaxWidth(Control.USE_PREF_SIZE);
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, mainTaskList.indexOf(task) + 1).getLayout());
            }
        }
    }
}
```
###### /java/seedu/agendum/ui/HelpWindow.java
``` java
/**
 * Controller for help anchorpane
 */
public class HelpWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String FXML = "HelpWindow.fxml";
    private static final int PADDING = 11;
    private static final double COMMAND_COLUMN_WIDTH = 0.2;
    private static final double DESCRIPTION_COLUMN_WIDTH = 0.4;
    private static final double FORMAT_COLUMN_WIDTH = 0.4;
    private final ObservableList<Map<CommandColumns, String>> commandList = FXCollections.observableArrayList();

    private enum CommandColumns {
        COMMAND, DESCRIPTION, FORMAT
    }
    
    @FXML
    private AnchorPane helpWindowRoot;
    
    @FXML
    private TableView<Map<CommandColumns, String>> commandTable;
    
    @FXML
    private TableColumn<Map<CommandColumns, String>, String> commandColumn;
    
    @FXML
    private TableColumn<Map<CommandColumns, String>, String> descriptionColumn;
    
    @FXML
    private TableColumn<Map<CommandColumns, String>, String> formatColumn;
    
    private StackPane messagePlaceHolder;
    private AnchorPane mainPane;
    
    /**
     * Initializes the controller class. This method is automatically called
     * after the fxml file has been loaded.
     */
    @FXML
    private void initialize() {
        
        commandColumn.setCellValueFactory(cellData ->  new SimpleStringProperty(cellData.getValue().get(CommandColumns.COMMAND)));
        descriptionColumn.setCellValueFactory(cellData ->  new SimpleStringProperty(cellData.getValue().get(CommandColumns.DESCRIPTION)));
        formatColumn.setCellValueFactory(cellData ->  new SimpleStringProperty(cellData.getValue().get(CommandColumns.FORMAT)));
        commandTable.setItems(commandList);
        commandTable.setEditable(false);
    }
    
    public static HelpWindow load(Stage primaryStage, StackPane messagePlaceHolder) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure(messagePlaceHolder);
        return helpWindow;
    }
    
    @Override
    public void setNode(Node node) {
        this.mainPane = (AnchorPane)node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    public AnchorPane getMainPane() {
        return this.mainPane;
    }

    private void configure(StackPane messagePlaceHolder){
        this.messagePlaceHolder = messagePlaceHolder;
        commandColumn.prefWidthProperty().bind(commandTable.widthProperty().multiply(COMMAND_COLUMN_WIDTH));
        descriptionColumn.prefWidthProperty().bind(commandTable.widthProperty().multiply(DESCRIPTION_COLUMN_WIDTH));
        formatColumn.prefWidthProperty().bind(commandTable.widthProperty().multiply(FORMAT_COLUMN_WIDTH));
        loadHelpList();
    }
    
    public void show(double height) {
        this.messagePlaceHolder.setPadding(new Insets(PADDING));
        this.helpWindowRoot.setMinHeight(height);
        this.messagePlaceHolder.setPrefSize(Control.USE_COMPUTED_SIZE, Control.USE_COMPUTED_SIZE);
        this.messagePlaceHolder.getChildren().add(helpWindowRoot);
    }

```
###### /java/seedu/agendum/ui/MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing a menu bar
 * and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);

    private static final String ICON = "/images/agendum_icon.png";
    private static final String FXML = "MainWindow.fxml";
    private static final String LIST_COMMAND = "list";
    private static final String UNDO_COMMAND = "undo";

    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private TasksPanel upcomingTasksPanel;
    private TasksPanel completedTasksPanel;
    private TasksPanel floatingTasksPanel;
    private AnchorPane helpWindow;
    private ResultPopUp resultPopUp;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private Config config;
    private UserPrefs userPrefs;

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    @FXML
    private AnchorPane browserPlaceholder;

    @FXML
    private AnchorPane commandBoxPlaceholder;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private SplitPane splitPane;
    
    @FXML
    private AnchorPane upcomingTasksPlaceHolder;

    @FXML
    private AnchorPane completedTasksPlaceHolder;

    @FXML
    private AnchorPane floatingTasksPlaceHolder;

    @FXML
    private AnchorPane statusbarPlaceholder;

    @FXML
    private StackPane messagePlaceHolder;

    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, Config config, UserPrefs prefs, Logic logic) {

        this.logic = logic;
        this.config = config;
        this.userPrefs = prefs;

        setTitle(appTitle);
        setIcon(ICON);
        setWindowDefaultSize(prefs);
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);
        primaryStage.setOnCloseRequest(e -> Platform.exit());
        configureEscape();
        configureHelpWindowToggle();
    }
    
    /**
     * Set shortcut key to switch between help window and main window
     */
    private void configureHelpWindowToggle() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            KeyCombination toggleHelpWindow = new KeyCodeCombination(KeyCode.H, KeyCombination.CONTROL_DOWN);
            KeyCombination undo = new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN);
            @Override
            public void handle(KeyEvent evt) {
                if (toggleHelpWindow.match(evt) && messagePlaceHolder.getChildren().size() == 0) {
                    openHelpWindow();
                } else if (toggleHelpWindow.match(evt) && messagePlaceHolder.getChildren().contains(helpWindow)) {
                    closeHelpWindow();
                } else if(undo.match(evt)) {
                    logic.execute(UNDO_COMMAND);
                }
            }
        });
    }
    
    /**
     * Set shortcut key to quickly switch back to main list after using find
     * command or showing help page
     */
    private void configureEscape() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, evt -> {
            if (evt.getCode().equals(KeyCode.ESCAPE) && messagePlaceHolder.getChildren().contains(helpWindow)) {
                closeHelpWindow();
            } else if(evt.getCode().equals(KeyCode.ESCAPE) && messagePlaceHolder.getChildren().size() > 0) {
                messagePlaceHolder.getChildren().clear();
                messagePlaceHolder.setMaxHeight(0);
                logic.execute(LIST_COMMAND);
            }
        });
    }

    /**
     * Loads the ui elements
     */
    public void fillInnerParts() {
        logger.info("loading ui elements");
        upcomingTasksPanel = UpcomingTasksPanel.load(primaryStage, getUpcomingTasksPlaceHolder(),
                logic.getFilteredTaskList(), new UpcomingTasksPanel());
        completedTasksPanel = CompletedTasksPanel.load(primaryStage, getCompletedTasksPlaceHolder(),
                logic.getFilteredTaskList(), new CompletedTasksPanel());
        floatingTasksPanel = FloatingTasksPanel.load(primaryStage, getFloatingTasksPlaceHolder(),
                logic.getFilteredTaskList(), new FloatingTasksPanel());
        resultPopUp = ResultPopUp.load(primaryStage);
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getToDoListFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), messagePlaceHolder, resultPopUp, logic);
    }

    public AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    public StackPane getMessagePlaceHolder() {
        return messagePlaceHolder;
    }

    public AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    public AnchorPane getUpcomingTasksPlaceHolder() {
        return upcomingTasksPlaceHolder;
    }

    public AnchorPane getCompletedTasksPlaceHolder() {
        return completedTasksPlaceHolder;
    }

    public AnchorPane getFloatingTasksPlaceHolder() {
        return floatingTasksPlaceHolder;
    }

    public UpcomingTasksPanel getUpcomingTasksPanel() {
        return (UpcomingTasksPanel) this.upcomingTasksPanel;
    }

    public CompletedTasksPanel getCompletedTasksPanel() {
        return (CompletedTasksPanel) this.completedTasksPanel;
    }

    public FloatingTasksPanel getFloatingasksPanel() {
        return (FloatingTasksPanel) this.floatingTasksPanel;

    }

```
###### /java/seedu/agendum/ui/MainWindow.java
``` java
    @FXML
    public void handleHelp() {
        if(!messagePlaceHolder.getChildren().contains(helpWindow)) {
            openHelpWindow();
        }
        
    }
    
    public void openHelpWindow() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage, messagePlaceHolder);
        this.helpWindow = helpWindow.getMainPane();
        helpWindow.show(upcomingTasksPlaceHolder.getHeight());
        rootLayout.getChildren().remove(rootLayout.getChildren().indexOf(splitPane));
    }
    
    public void closeHelpWindow() {
        messagePlaceHolder.getChildren().clear();
        messagePlaceHolder.setMaxHeight(0);
        messagePlaceHolder.setPadding(new Insets(0));
        if(!rootLayout.getChildren().contains(splitPane)) {
            rootLayout.getChildren().add(rootLayout.getChildren().indexOf(statusbarPlaceholder), splitPane);
        }
    }

    public void hide() {
        primaryStage.hide();
    }

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

}
```
###### /java/seedu/agendum/ui/ResultPopUp.java
``` java
/**
 * Controller for a pop up window that shows command execution result
 */
public class ResultPopUp extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(ResultPopUp.class);
    private static final String FXML = "ResultPopUp.fxml";
    private static Stage root;
    private AnchorPane mainPane;
    private Stage dialogStage;

    private final PauseTransition delay = new PauseTransition(Duration.seconds(5));

    @FXML
    private Label resultDisplay;

    public static ResultPopUp load(Stage primaryStage) {
        logger.fine("Showing command execution result.");
        root = primaryStage;
        ResultPopUp resultPopUp = UiPartLoader.loadUiPart(primaryStage, new ResultPopUp());
        resultPopUp.configure();
        return resultPopUp;
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure() {

        Scene scene = new Scene(mainPane);

        dialogStage = createDialogStage(null, null, scene);
        dialogStage.initModality(Modality.NONE);
        dialogStage.setAlwaysOnTop(true);
        dialogStage.setOnShown((e1) -> primaryStage.requestFocus());

        scene.setFill(Color.TRANSPARENT);
        dialogStage.initStyle(StageStyle.TRANSPARENT);
        
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        dialogStage.setMaxHeight(screenSize.getWidth());
        dialogStage.setMaxWidth(screenSize.getHeight());
    }
    
    private boolean isShowingMessage() {
        return dialogStage.isShowing() && dialogStage.getOpacity() != 0;
    }

    /**
     * Shows message in a pop up window for several seconds
     * @param message The command execution result to be shown
     */
    public void postMessage(String message) {
        
        if(this.isShowingMessage()) {
            delay.playFromStart();
        } else {
            delay.setOnFinished(event -> dialogStage.setOpacity(0));
            delay.play();
        }
        
        resultDisplay.setWrapText(true);
        resultDisplay.setText(message);
        show();
    }
    
    private void show() {
        dialogStage.setOpacity(1.0);
        dialogStage.sizeToScene();
        dialogStage.show();
        dialogStage.setX(root.getX() + root.getWidth() / 2 - dialogStage.getWidth() / 2);
        dialogStage.setY(root.getY() + root.getHeight() / 2 - dialogStage.getHeight() / 2);
    }
}
```
###### /java/seedu/agendum/ui/StatusBarFooter.java
``` java
    private void addTimeStatus() {
        Label timeStatus = new DigitalClock();
        FxViewUtil.applyAnchorBoundaryParameters(timeStatus, 0.0, 0.0, 0.0, 0.0);
        timeStatus.setAlignment(Pos.CENTER);
        timeStatusBarPane.getChildren().add(timeStatus);
    }
    
    @Override
    public void setNode(Node node) {
        mainPane = (GridPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }

```
###### /java/seedu/agendum/ui/StatusBarFooter.java
``` java
class DigitalClock extends Label {

    private static final String DATE_TIME_PATTERN = "HH:mm, EEE d MMM yyyy";

    public DigitalClock() {
        bindToTime();
    }

    private void bindToTime() {
        Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(0), actionEvent -> {
            Calendar time = Calendar.getInstance();
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATE_TIME_PATTERN);
            setText(simpleDateFormat.format(time.getTime()));
            setTextFill(Color.web("#ffffff"));
        }), new KeyFrame(Duration.seconds(1)));

        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }
}
```
###### /java/seedu/agendum/ui/TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final String FXML = "TaskCard.fxml";
    private static final String OVERDUE_PREFIX = "Overdue\n";
    private static final String COMPLETED_PREFIX = "Completed on ";
    private static final String TASK_TIME_PATTERN = "HH:mm EEE, dd MMM";
    private static final String COMPLETED_TIME_PATTERN = "EEE, dd MMM";
    private static final String START_TIME_PREFIX = "from ";
    private static final String END_TIME_PREFIX = " to ";
    private static final String DEADLINE_PREFIX = "by ";
    private static final String EMPTY_PREFIX = "";
    private static final String OVERDUE_STYLE = "-fx-background-color: rgba(244, 67, 54, 0.8)";
    private static final String UPCOMING_STYLE = "-fx-background-color: rgba(255, 235, 59, 0.8)";
    private static final String OTHER_STYLE = "-fx-background-color: rgba(255,255,255,0.6)";
    private static final Color NAME_COLOR_DARK = Color.web("#3a3d42");
    private static final Color TIME_COLOR_DARK = Color.web("#4172c1");
    private static final Color NAME_COLOR_LIGHT = Color.web("#ffffff");
    private static final Color TIME_COLOR_LIGHT = Color.web("#fff59d");

    @FXML
    private HBox cardPane;
    @FXML
    private VBox taskVbox;
    @FXML
    private Label name;
    @FXML
    private Label id;

    private ReadOnlyTask task;
    private String displayedIndex;

    public TaskCard() {
    }

    public static TaskCard load(ReadOnlyTask task, int Index) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = String.valueOf(Index) + ".";
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {

        Label time = new Label();
        time.setId("time");

        if (task.isOverdue()) {
            cardPane.setStyle(OVERDUE_STYLE);
            name.setTextFill(NAME_COLOR_LIGHT);
            time.setTextFill(TIME_COLOR_LIGHT);
            id.setTextFill(NAME_COLOR_LIGHT);
        } else if (task.isUpcoming()) {
            cardPane.setStyle(UPCOMING_STYLE);
            name.setTextFill(NAME_COLOR_DARK);
            time.setTextFill(TIME_COLOR_DARK);
        } else {
            cardPane.setStyle(OTHER_STYLE);
            name.setTextFill(NAME_COLOR_DARK);
            time.setTextFill(TIME_COLOR_DARK);
        }

        StringBuilder timeDescription = new StringBuilder();
        timeDescription.append(formatTaskTime(task));

        if (task.isCompleted()) {
            timeDescription.append(formatUpdatedTime(task));
        }

        name.setText(task.getName().fullName);
        id.setText(displayedIndex);
        time.setText(timeDescription.toString());
        time.setMaxHeight(Control.USE_COMPUTED_SIZE);
        time.setWrapText(true);
        
        if (task.hasTime() || task.isCompleted()) {
            taskVbox.getChildren().add(time);
            taskVbox.setAlignment(Pos.CENTER_LEFT);
            time.setAlignment(Pos.CENTER_LEFT);
            time.setFont(Font.font("Verdana", FontPosture.ITALIC, 11));
        }
    }

    private String formatTime(String dateTimePattern, String prefix, Optional<LocalDateTime> dateTime) {

        StringBuilder sb = new StringBuilder();
        DateTimeFormatter format = DateTimeFormatter.ofPattern(dateTimePattern);
        sb.append(prefix).append(dateTime.get().format(format));
        
        return sb.toString();
    }

    private String formatTaskTime(ReadOnlyTask task) {
        
        StringBuilder timeStringBuilder = new StringBuilder();

        if (task.isOverdue()) {
            timeStringBuilder.append(OVERDUE_PREFIX);
        }

        if (task.isEvent()) {
            String startTime = formatTime(TASK_TIME_PATTERN, START_TIME_PREFIX, task.getStartDateTime());
            String endTime = formatTime(TASK_TIME_PATTERN, END_TIME_PREFIX, task.getEndDateTime());
            timeStringBuilder.append(startTime);
            timeStringBuilder.append(endTime);
        } else if (task.hasDeadline()) {
            String deadline = formatTime(TASK_TIME_PATTERN, DEADLINE_PREFIX, task.getEndDateTime());
            timeStringBuilder.append(deadline);
        }

        return timeStringBuilder.toString();
    }

    private String formatUpdatedTime(ReadOnlyTask task) {
        StringBuilder timeStringBuilder = new StringBuilder();
        if (task.hasTime()) {
            timeStringBuilder.append("\n");
        }
        timeStringBuilder.append(COMPLETED_PREFIX);
        timeStringBuilder.append(formatTime(COMPLETED_TIME_PATTERN, EMPTY_PREFIX,
                Optional.ofNullable(task.getLastUpdatedTime())));
        return timeStringBuilder.toString();
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/seedu/agendum/ui/TasksPanel.java
``` java
/**
 * Panel that contains the list of tasks
 */
public abstract class TasksPanel extends UiPart{
    private AnchorPane panel;
    private AnchorPane placeHolderPane;
    
    public TasksPanel() {
        super();
    }
    
    @Override
    public void setNode(Node node) {
        panel = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public static TasksPanel load(Stage primaryStage, AnchorPane tasksPlaceholder,
            ObservableList<ReadOnlyTask> taskList, TasksPanel tasksPanelType) {
        TasksPanel tasksPanel = UiPartLoader.loadUiPart(primaryStage, tasksPlaceholder, tasksPanelType);
        tasksPanel.configure(taskList);
        return tasksPanel;
    }
    
    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }
    
    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }
    
    protected abstract void setConnections(ObservableList<ReadOnlyTask> allTasks);
    
    public abstract void scrollTo(Task task, boolean hasMultipleTasks);
    
}
```
###### /java/seedu/agendum/ui/UpcomingTasksPanel.java
``` java
/**
 * Panel contains the list of all uncompleted tasks with time
 */
public class UpcomingTasksPanel extends TasksPanel {
    private static final String FXML = "UpcomingTasksPanel.fxml";
    private static ObservableList<ReadOnlyTask> mainTaskList;
    private MultipleSelectionModel<ReadOnlyTask> selectionModel;

    @FXML
    private ListView<ReadOnlyTask> upcomingTasksListView;

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    protected void setConnections(ObservableList<ReadOnlyTask> taskList) {
        mainTaskList = taskList;
        upcomingTasksListView.setItems(taskList.filtered(task -> task.hasTime() && !task.isCompleted()));
        upcomingTasksListView.setCellFactory(listView -> new upcomingTasksListViewCell());
        configure();
    }
    
    private void configure() {
        selectionModel = upcomingTasksListView.getSelectionModel();
        upcomingTasksListView.setSelectionModel(null);
        upcomingTasksListView.addEventFilter(MouseEvent.MOUSE_PRESSED, Event::consume);
    }

    /**
     * Scrolls to the newly updated task and highlight for several seconds. If
     * there are multiple tasks updated, previous highlight will not be cleared.
     */
    public void scrollTo(Task task, boolean hasMultipleTasks) {
        Platform.runLater(() -> {
            
            int index = mainTaskList.indexOf(task);
            upcomingTasksListView.scrollTo(index);
            upcomingTasksListView.setSelectionModel(selectionModel);
            
            if(hasMultipleTasks) {
                upcomingTasksListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
                upcomingTasksListView.getSelectionModel().select(index);
            } else {
                upcomingTasksListView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
                upcomingTasksListView.getSelectionModel().clearAndSelect(index);
            }
            
            PauseTransition delay = new PauseTransition(Duration.seconds(5));
            delay.setOnFinished(event -> upcomingTasksListView.getSelectionModel().clearSelection(index));
            delay.play();
        });
    }

    class upcomingTasksListViewCell extends ListCell<ReadOnlyTask> {

        public upcomingTasksListViewCell() {
            prefWidthProperty().bind(upcomingTasksListView.widthProperty());
            setMaxWidth(Control.USE_PREF_SIZE);
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, mainTaskList.indexOf(task) + 1).getLayout());
            }
        }
    }

}
```
###### /resources/view/CompletedTasksPanel.fxml
``` fxml

<AnchorPane minWidth="0.0" styleClass="completed-pane" stylesheets="@TasksPanel.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.CompletedTasksPanel">
   <children>
      <ListView fx:id="completedTasksListView" minWidth="0.0" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="60.0" />
      <HBox alignment="CENTER" layoutX="130.0" layoutY="15.0" minWidth="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
         <children>
            <ImageView fitHeight="50.0" fitWidth="22.0" pickOnBounds="true" preserveRatio="true">
               <image>
                  <Image url="@../images/completedTasksPanel.png" />
               </image>
            </ImageView>
            <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" text="Done ~" textAlignment="CENTER" wrappingWidth="130" HBox.hgrow="ALWAYS">
               <font>
                  <Font size="22.0" />
               </font>
            </Text>
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### /resources/view/DarkTheme.css
``` css
.background {
    -fx-background-color: derive(#263238, 20%);
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.split-pane:horizontal .split-pane-divider {
    -fx-border-color: transparent;
    -fx-background-color: transparent;
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 1;
    -fx-background-color: derive(#263238, 20%);
}

.anchor-pane {
     -fx-background-color: derive(#263238, 20%);
}

.anchor-pane-with-border {
     -fx-background-color: derive(#263238, 20%);
     -fx-border-color: transparent;
     -fx-border-top-width: 1px;
}

.stack-pane {
     -fx-background-color: derive(#263238, 20%);
     -fx-border-color: transparent;
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: derive(#263238, 20%);
    -fx-border-color: transparent;
    -fx-text-fill: white;
}

.result-display {
    -fx-background-color: #ffffff;
}

.result-display {
    -fx-text-fill: black;
}

.status-bar .label {
	-fx-background-color: transparent;
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: derive(#263238, 30%);
    -fx-border-color: transparent;
    -fx-border-width: 1px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.grid-pane {
    -fx-background-color: derive(#263238, 30%);
    -fx-border-color: derive(#263238, 30%);
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: derive(#263238, 20%);
}

.context-menu {
    -fx-background-color: derive(#263238, 50%);
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color: derive(#263238, 20%);
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #263238;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #263238;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #263238;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #263238;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #263238;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#263238, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}

.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button {
    -fx-padding:0;
}

.list-view {
	-fx-background-radius: 10;
}

#cardPane {
    -fx-background-color: transparent;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #taskListPanel, #taskWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}
```
###### /resources/view/FloatingTasksPanel.fxml
``` fxml

<AnchorPane styleClass="other-pane" stylesheets="@TasksPanel.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.FloatingTasksPanel">
   <children>
      <ListView fx:id="floatingTasksListView" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="60.0" />
      <HBox alignment="CENTER" layoutX="130.0" layoutY="15.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
         <children>
            <ImageView fitHeight="50.0" fitWidth="22.0" pickOnBounds="true" preserveRatio="true">
               <image>
                  <Image url="@../images/floatingTasksPanel.png" />
               </image>
            </ImageView>
            <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" text="Do It Anytime ~" textAlignment="CENTER" wrappingWidth="190.0" HBox.hgrow="ALWAYS">
               <font>
                  <Font size="22.0" />
               </font>
            </Text>
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### /resources/view/HelpWindow.css
``` css

.pane {
	-fx-background-color: #EA6254;
	-fx-background-radius: 10;
}

.button {
	-fx-background-color: rgba(0,0,0,0.1);
	-fx-background-radius: 10;
}

.button:hover {
	-fx-background-color: rgba(0,0,0,0.3);
	-fx-background-radius: 10;
}

.table-view:focused{
    -fx-background-color: transparent;
}

.table-view{
   -fx-background-color: transparent;
}

.table-view .column-header-background{
    -fx-background-color: transparent;
}

.table-view .column-header-background .label{
    -fx-background-color: transparent;
    -fx-text-fill: white;
    -fx-font-size: 16pt;
}

.table-view .column-header {
    -fx-background-color: transparent;
}

.table-view .table-cell{
    -fx-text-fill: white;
    -fx-font-size: 14pt;
}

.table-cell:empty {
	-fx-background-color: transparent;
}

.table-row-cell{
	-fx-table-cell-border-color: transparent;
    -fx-background-color: transparent;
}

.table-row-cell:even{
	-fx-table-cell-border-color: transparent;
    -fx-background-color: rgba(255,255,255,0.3);
}

.table-row-cell:hover{
    -fx-background-color: rgba(0,0,0,0.1);
}

.scroll-bar .increment-button {
  -fx-opacity: 0;
}

.scroll-bar .decrement-button {
  -fx-opacity: 0;
}

.scroll-bar {
  -fx-background-color: transparent;
}

.scroll-bar .track-background {
  -fx-opacity: 0;
  -fx-background-color: transparent;
  -fx-background-insets: 0;
}

.scroll-bar .track {
  -fx-opacity: 0;
  -fx-background-color: transparent;
  -fx-border-color:transparent;
}

.scroll-bar .thumb {
  -fx-background-color: transparent;
  -fx-background-insets: 4 0 4 0;
  -fx-background-radius: 2em;
}

.table-view .scroll-bar:vertical .increment-arrow,
.table-view .scroll-bar:vertical .decrement-arrow,
.table-view .scroll-bar:vertical .increment-button,
.table-view .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}

.table-view .scroll-bar:horizontal .increment-arrow,
.table-view .scroll-bar:horizontal .decrement-arrow,
.table-view .scroll-bar:horizontal .increment-button,
.table-view .scroll-bar:horizontal .decrement-button {
    -fx-padding:0;
}
```
###### /resources/view/HelpWindow.fxml
``` fxml

<AnchorPane fx:id="helpWindowRoot" styleClass="pane" stylesheets="@HelpWindow.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.HelpWindow">
   <children>
      <TableView fx:id="commandTable" styleClass="pane" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="48.0">
        <columns>
          <TableColumn fx:id="commandColumn" text="Command" />
          <TableColumn fx:id="descriptionColumn" text="Description" />
            <TableColumn fx:id="formatColumn" text="Format" />
        </columns>
      </TableView>
      <HBox alignment="CENTER" layoutX="130.0" layoutY="15.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
         <children>
            <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" text="Help" textAlignment="CENTER" wrappingWidth="199.0" HBox.hgrow="ALWAYS">
               <font>
                  <Font size="25.0" />
               </font>
            </Text>
         </children>
      </HBox>
      <Label text="Press ESC to go back" textFill="WHITE">
         <font>
            <Font size="13.0" />
         </font>
         <padding>
            <Insets left="10.0" top="5.0" />
         </padding>
      </Label>
   </children>
</AnchorPane>
```
###### /resources/view/MainWindow.fxml
``` fxml

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help Ctrl-H" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <StackPane fx:id="messagePlaceHolder" styleClass="stack-pane">
         <padding>
            <Insets left="10.0" right="10.0" />
         </padding>
      </StackPane>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4, 1.0" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="taskList">
                <padding>
                    <Insets bottom="10.0" left="5.0" right="5.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="upcomingTasksPlaceHolder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
            <VBox>
               <children>
                  <AnchorPane fx:id="floatingTasksPlaceHolder" VBox.vgrow="ALWAYS" />
               </children>
               <padding>
                  <Insets bottom="10.0" left="5.0" right="5.0" top="10.0" />
               </padding>
            </VBox>
            <VBox>
               <children>
                  <AnchorPane fx:id="completedTasksPlaceHolder" VBox.vgrow="ALWAYS" />
               </children>
               <padding>
                  <Insets bottom="10.0" left="5.0" right="5.0" top="10.0" />
               </padding>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### /resources/view/ResultPopUp.css
``` css
.pane {
    -fx-background-color: rgb(229,74,63);
    -fx-background-radius: 20;
    -fx-padding: 10px;
}

.label {
	-fx-text-fill: white;
	-fx-font-size: 14pt;
}
```
###### /resources/view/ResultPopUp.fxml
``` fxml

<AnchorPane styleClass="pane" stylesheets="@ResultPopUp.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.ResultPopUp">
   <children>
      <Label fx:id="resultDisplay" alignment="CENTER" text="Label" wrapText="true" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
   </children>
</AnchorPane>
```
###### /resources/view/StatusBarFooter.fxml
``` fxml
<GridPane styleClass="grid-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.StatusBarFooter">
<columnConstraints>
  <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
  <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
</columnConstraints>
 <children>
      <AnchorPane id="syncStatusBarPane" fx:id="syncStatusBarPane" minWidth="0.0" styleClass="anchor-pane" />
      <AnchorPane id="saveLocStatusBarPane" fx:id="saveLocStatusBarPane" minWidth="0.0" styleClass="anchor-pane" GridPane.columnIndex="1" />
      <AnchorPane id="timeStatusBarPane" fx:id="timeStatusBarPane" styleClass="anchor-pane" GridPane.columnIndex="2" />
 </children>
   <rowConstraints>
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### /resources/view/TaskCard.fxml
``` fxml

<HBox fx:id="cardPane" alignment="CENTER_LEFT" styleClass="hbox" stylesheets="@TasksPanel.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <GridPane alignment="CENTER_LEFT" style="-fx-background-color: transparent;">
         <HBox.margin>
            <Insets />
         </HBox.margin>
         <columnConstraints>
            <ColumnConstraints hgrow="ALWAYS" />
            <ColumnConstraints hgrow="ALWAYS" />
         </columnConstraints>
         <rowConstraints>
            <RowConstraints minHeight="10.0" vgrow="SOMETIMES" />
         </rowConstraints>
         <children>
            <Label fx:id="id" minWidth="40.0" styleClass="cell_big_label" stylesheets="@TasksPanel.css" text="\$ID" wrapText="true" />
            <VBox fx:id="taskVbox" alignment="CENTER" styleClass="vbox" GridPane.columnIndex="1">
               <children>
                  <Label fx:id="name" styleClass="cell_big_label" stylesheets="@TasksPanel.css" text="\$task" wrapText="true">
                     <padding>
                        <Insets right="20.0" />
                     </padding>
                  </Label>
               </children>
            </VBox>
         </children>
      </GridPane>
   </children>
   <padding>
      <Insets bottom="3.0" left="5.0" right="3.0" top="3.0" />
   </padding>
</HBox>
```
###### /resources/view/TasksPanel.css
``` css
.all-pane {
	-fx-background-color:  #4DB6AC;
	-fx-background-radius: 10;
}

.completed-pane {
	-fx-background-color:  #727a87;
	-fx-background-radius: 10;
}

.other-pane {
	-fx-background-color:  #3498DB;
	-fx-background-radius: 10;
}

.list-view {
	-fx-background-color: transparent;
	-fx-background-radius: 10;
}

.list-cell {
	-fx-background-color: transparent;
    -fx-background-radius: 10;
}

.list-cell:empty  {
	-fx-background-color: transparent;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: #3949AB;
    -fx-text-fill: red;
}

.cell_big_label {
    -fx-font-size: 14pt;
    -fx-opacity: 0.9;
}

.cell_small_label {
    -fx-text-fill: #3a3d42;
    -fx-opacity: 0.9;
}

.hbox {
	-fx-background-radius: 10;
}

.vbox {
	-fx-background-color: transparent;
}
```
###### /resources/view/UpcomingTasksPanel.fxml
``` fxml

<AnchorPane styleClass="all-pane" stylesheets="@TasksPanel.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.agendum.ui.UpcomingTasksPanel">
   <children>
      <ListView fx:id="upcomingTasksListView" layoutX="2.0" layoutY="48.0" styleClass="list" stylesheets="@TasksPanel.css" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="60.0" />
      <HBox alignment="CENTER" layoutX="130.0" layoutY="15.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
         <children>
            <ImageView fitHeight="50.0" fitWidth="22.0" pickOnBounds="true" preserveRatio="true">
               <image>
                  <Image url="@../images/upcomingTasksPanel.png" />
               </image>
            </ImageView>
            <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" text="Do It Soon ~" textAlignment="CENTER" wrappingWidth="170.0" HBox.hgrow="ALWAYS">
               <font>
                  <Font size="22.0" />
               </font>
            </Text>
         </children>
      </HBox>
   </children>
</AnchorPane>
```
